# Rbot Navigation Cog
#
# Server-only
# Type ID: 1000
#
# Rbots originally created by Raynar
# Additional code by Hell Raiser

flags=0x40

symbols

message startup
message trigger

# The known paths
cog path0=-1 local
cog path1=-1 local
cog path2=-1 local
cog path3=-1 local
cog path4=-1 local
cog path5=-1 local
cog path6=-1 local
cog path7=-1 local
cog path8=-1 local
cog path9=-1 local
cog path10=-1 local
cog path11=-1 local
cog path12=-1 local
cog path13=-1 local
cog path14=-1 local
cog path15=-1 local
cog path16=-1 local
cog path17=-1 local
cog path18=-1 local
cog path19=-1 local
cog path20=-1 local
cog path21=-1 local
cog path22=-1 local
cog path23=-1 local
cog path24=-1 local
cog path25=-1 local
cog path26=-1 local
cog path27=-1 local
cog path28=-1 local
cog path29=-1 local
cog path30=-1 local
cog path31=-1 local
cog path32=-1 local
cog path33=-1 local
cog path34=-1 local
cog path35=-1 local
cog path36=-1 local
cog path37=-1 local
cog path38=-1 local
cog path39=-1 local
cog path40=-1 local
cog path41=-1 local
cog path42=-1 local
cog path43=-1 local
cog path44=-1 local
cog path45=-1 local
cog path46=-1 local
cog path47=-1 local
cog path48=-1 local
cog path49=-1 local

# The number of nodes in this path
int path_count=0 local

int path_size_max=25 local # Keep in sync with path cog

# Working variables

int i local
int j local
int path_index local
int node_index local

cog cur_path local

cog path local
int path_size local
thing node local
flex dist local
int path_rank local
int path_rundir local

cog new_path local
int new_path_size local
thing new_node local
flex new_dist local
int new_path_rank local
int new_path_rundir local

vector bot_z local
vector new_node_z local
vector bot_pos local
vector new_node_pos local

int botid local
thing rbot local
cog srv local
cog srv2 local
int botmode local
int lastposnum local
int nextposnum local
int rundir local
int changepath local
int path_end local
int new_path_end local
int looping local
int new_path_requirements local
int bot_keys local
int navspecial local

end

code

startup:
	if (!IsServer()) {
		// Server-only
		return;
	}

	// Allow other server-side cogs to discover this one by its type
	SendTrigger(-1, 1852000, 1000, GetSelfCog(), -1, -1);

	return;

trigger:
	if (!IsServer()) {
		// Server-only
		return;
	}

	if (GetSourceRef() == 1852000) {
		// Rbot cog type discovery
		if (GetParam(0) == 1001) {
			// Path cog registered
			path0[path_count] = GetParam(1);
			path_count = path_count + 1;
		}
		return;
	}

	if (GetSourceRef() == 10000) {
		// Bot wants to know next location
		botid = GetParam(0); // which bot requested the info
		rbot = GetParam(1);
		botmode = GetParam(2);
		lastposnum = GetParam(3);

		if (lastposnum == -1) {
			// bot lost - find nearest node
			path_index = -1;
			node_index = -1;
			node = -1;
			rundir = -1;
			dist = 10000;
			bot_pos = GetThingPos(rbot);
			bot_z = VectorSet(0, 0, VectorZ(bot_pos));

			for (i = 0 ; i < path_count ; i = i + 1) {
				new_path = path0[i];

				// Check path requirements (e.g. keys)
				new_path_requirements = SendMessageEx(new_path, user0, 104, -1, -1, -1);
				srv = GetThingCaptureCog(rbot);
				srv2 = SendMessageEx(srv, user7, 1100, -1, -1, -1);
				bot_keys = SendMessageEx(srv2, user7, 1008, -1, -1, -1);
				if (BitClear(new_path_requirements, bot_keys) == 0) {
					// Bot has all the keys, etc. necessary to use this path
					SendMessageEx(new_path, user1, 200, rbot, -1, -1);
					new_path_rundir = SendMessageEx(new_path, user2, 1, -1, -1, -1);
					new_path_size = SendMessageEx(new_path, user0, 100, -1, -1, -1);
					for (j = 0 ; j < new_path_size ; j = j + 1) {
						new_node = SendMessageEx(new_path, user0, 101, j, -1, -1);
						if (new_node != node) {
							// See if any special navigation flags have been set for this node
							navspecial = 0;
							SendTrigger(-1, 11060, new_node, -1, -1, -1);
							if (!BitTest(navspecial, 0x1)) {
								// A lost bot is allowed to go directly to this node to get back on track
								new_node_pos = GetThingPos(new_node);
								new_dist = VectorDist(bot_pos, new_node_pos);
								new_node_z = VectorSet(0, 0, VectorZ(new_node_pos));
								if (new_dist < dist && HasLOS(rbot, new_node) && (VectorDist(bot_z, new_node_z) < 0.4 || (GetThingFlags(rbot) & 0x2000000 && GetThingFlags(new_node) & 0x2000000))) {
									// Node is closer, bot can see it, and not too high to reach
									path_index = i;
									node_index = j;
									path = new_path;
									node = new_node;
									dist = new_dist;
									rundir = new_path_rundir;
								}
							}
						}
					}
				}
			}

			// If the chosen path (if any) does not require a particular run direction, pick one randomly
			if (rundir == -1) {
				if (Rand() > 0.5) {
					rundir = 1;
				} else {
					rundir = 0;
				}
			}
		} else {
			// Bot reached current node, needs to know where to go next
			node_index = lastposnum % path_size_max;
			path_index = (lastposnum - node_index) / path_size_max;

			path = path0[path_index];
			path_size = SendMessageEx(path, user0, 100, -1, -1, -1);
			node = SendMessageEx(path, user0, 101, node_index, -1, -1);

			SendMessageEx(path, user1, 200, rbot, -1, -1);
			path_rank = SendMessageEx(path, user2, 0, -1, -1, -1);
			path_rundir = SendMessageEx(path, user2, 1, -1, -1, -1);

			// Validate bot state and make corrections if needed
			// State issues can happen after e.g. getting lost and changes in CTF game state
			if (path_rundir != -1) {
				// Make sure bot is running in the path's required direction
				rundir = path_rundir;
			} else {
				// Current path does not have a required run direction, so keep the bot's current run direction
				if (BitTest(botmode,0x1000)) rundir=0; else rundir=1; // set run direction from botmode
			}

			// If we're at either end of a non-looping path, we should change paths if we can
			path_end = 0;
			looping = SendMessageEx(path, user0, 103, -1, -1, -1);
			if (!looping) {
				if (rundir == 1 && node_index >= (path_size - 1)) {
					// At end of path and running forward
					path_end = 1;
				} else if (rundir == 0 && node_index <= 0) {
					// At beginning of path and running backward
					path_end = 1;
				}
			}

			// Check for path intersections to possibly change to another path
			cur_path = path;
			for (i = 0 ; i < path_count ; i = i + 1) {
				new_path = path0[i];
				if (new_path != cur_path) {
					// Different path
					new_path_size = SendMessageEx(new_path, user0, 100, -1, -1, -1);

					// Check path requirements (e.g. keys)
					new_path_requirements = SendMessageEx(new_path, user0, 104, -1, -1, -1);
					srv = GetThingCaptureCog(rbot);
					srv2 = SendMessageEx(srv, user7, 1100, -1, -1, -1);
					bot_keys = SendMessageEx(srv2, user7, 1008, -1, -1, -1);

					if (BitClear(new_path_requirements, bot_keys) == 0) {
						// Bot has all the keys, etc. necessary to use this path
						for (j = 0 ; j < new_path_size ; j = j + 1) {
							new_node = SendMessageEx(new_path, user0, 101, j, -1, -1);
							if (node == new_node) {
								// Same node = Intersection with the other path

								SendMessageEx(new_path, user1, 200, rbot, -1, -1);
								new_path_rank = SendMessageEx(new_path, user2, 0, -1, -1, -1);
								new_path_rundir = SendMessageEx(new_path, user2, 1, -1, -1, -1);

								// Don't switch to the end of a path going the wrong direction
								new_path_end = 0;
								if (j >= (new_path_size - 1)) {
									if (new_path_rundir == 1) {
										// New path requires forward movement, but we're already at the end
										new_path_end = 1;
									} else {
										// The only option is to move backward
										new_path_rundir = 0;
									}
								} else if (j <= 0) {
									if (new_path_rundir == 0) {
										// New path requires backward movement, but we're already at the beginning
										new_path_end = 1;
									} else {
										// The only option is to move forward
										new_path_rundir = 1;
									}
								}

								if (!new_path_end) {
									// Evaluate whether or not to change to this path
									changepath = 0;
									if (new_path_rank > path_rank) {
										// New path is better than the current option - we are obligated to switch
										changepath = 1;
									} else if (new_path_rank == path_rank) {
										// New path is same rank as current option - change at random or if at end of current path
										if (path_end || Rand() > 0.5) {
											changepath = 1;
										}
									}
									if (changepath) {
										path_end = 0; // Now that we've changed paths, no need to force another change
										path_index = i;
										node_index = j;
										path = new_path;
										path_size = new_path_size;
										path_rank = new_path_rank;
										rundir = new_path_rundir;
										j = new_path_size; // break (skip ahead to next path)
									}
								}
							}
						}
					}
				}
			}

			// If the path change does not require a particular run direction, pick one randomly
			if (rundir == -1) {
				if (Rand() > 0.5) {
					rundir = 1;
				} else {
					rundir = 0;
				}
			}

			// Prevent the bot from moving beyond either end of the path
			looping = SendMessageEx(path, user0, 103, -1, -1, -1);
			if (rundir == 1 && node_index >= (path_size - 1)) {
				// At end of path and running forward
				if (looping) {
					// For looping paths, just wrap to the beginning of the path
					node_index = 0;
				} else {
					// Else, the bot needs to turn around and run the other direction
					rundir = 0;
				}
			} else if (rundir == 0 && node_index <= 0) {
				// At beginning of path and running backward
				if (looping) {
					// For looping paths, just wrap to the end of the path
					node_index = path_size - 1;
				} else {
					// Else, the bot needs to turn around and run the other direction
					rundir = 1;
				}
			}

			// Advance to next node
			if (rundir) {
				node_index = node_index + 1; // Forward
			} else {
				node_index = node_index - 1; // Backward
			}
			node = SendMessageEx(path, user0, 101, node_index, -1, -1);
		}

		// Update bot navigation state
		if (node == -1) {
			// Couldn't find a node for the bot
			nextposnum = -1;
		} else {
			// Found a node, synthesize a legacy index number to identify the path and node for later updates
			nextposnum = path_index * path_size_max + node_index;
		}
		SendTrigger(-1, 11000, botid, node, nextposnum, rundir);
		return;
	}

	if (GetSourceRef() == 11070) {
		// Received special navigation info
		navspecial = GetParam(0);
		return;
	}

	return;

end
