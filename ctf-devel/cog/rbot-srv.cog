# Rbot Server - AI (synch)
#
# Server-only
# Type ID: 1020
#
# Rbots originally created by Raynar
# Additional code by Hell Raiser

flags=0x80

symbols

message		startup
message		killed
message		pulse
message		trigger
message		timer
message		damaged
message		user0
message		user1
message		user7

int			botid=0
int			botname=-1
# Bot's team
# 0 = no team
# 1 = red
# 2 = gold/yellow
# 3 = blue
# 4 = green
int			team=0
template	rtemp
int			characterflags=0

# Game setup options - set from startup cog
int			gamemode=0					local
int			difficulty=0				local

# Internal bot references
thing		rbot						local
int			botmode						local
cog			srv2						local
cog			srv_force					local

# Weapon fire projectiles
template	projectile_weap00=+rbotsaber		local
template	projectile_weap00a=+rbotsaber2		local
template	projectile_weap01=+punch			local
template	projectile_weap02=+bryarbolt		local
template	projectile_weap03=+stlaser			local
#template	projectile_weap05=+crossbowbolt		local
#template	projectile_weap05a=+crossbowbolt2	local
template	projectile_weap05b=+crossbowbolt3	local
template	projectile_weap06=+repeaterball		local
template	projectile_weap07=+raildet			local
template	projectile_weap07a=+raildet2		local
template	projectile_weap08=+seqchrg			local
template	projectile_weap08a=+seqchrg2		local
template	projectile_weap09=+concbullet		local
template	projectile_weap09a=+concblast2		local

# Projectiles to jump away from with saber
#template	dproj0=+raildet				local
#template	dproj1=+concbullet			local

# Item models
model		itemmodel0=conp.3do		local	desc=conc_rifle
model		itemmodel1=rldp.3do		local	desc=rail_gun
model		itemmodel2=rptp.3do		local	desc=repeater
model		itemmodel3=strp.3do		local	desc=st_rifle
model		itemmodel4=bowp.3do		local	desc=crossbow
model		itemmodel5=ecel.3do		local	desc=energy_cell
model		itemmodel6=pcel.3do		local	desc=power_cell
model		itemmodel7=rcrg.3do		local	desc=rail_dets
model		itemmodel8=detp.3do		local	desc=thermal_dets
model		itemmodel9=seqp.3do		local	desc=sequencers
model		itemmodel10=hepk.3do	local	desc=health
model		itemmodel11=shld.3do	local	desc=shield
model		itemmodel12=vest.3do	local	desc=full_shield
model		itemmodel13=flgr.3do	local	desc=red_flag
model		itemmodel14=flgy.3do	local	desc=gold_flag
#model		itemmodel15=seq0.3do	local	desc=live_sequencer
model		itemmodel16=r-key.3do	local	desc=red_key
model		itemmodel17=y-key.3do	local	desc=gold_key

# Misc
int			curweap			local
thing		node			local
flex		nodesize		local
vector		waitpos			local
vector		lastbotpos		local
vector		newpos			local
int			lastposnum		local
thing		target			local
vector		blindvec		local
int			targweap		local
int			firing=0		local
# Which direction the bot is running
# 0 = backward
# 1 = forward
int			rundir			local
int			shields			local
int			stopcount		local
thing		newitem			local
thing		prevnode		local
int			lostcount		local
int			drowning		local
int			captured_red	local
int			captured_gold	local
int			redflag_taken	local
int			goldflag_taken	local
int			allowdodge		local
int			arrival_event	local

# Transient working vars
vector		relpos			local
flex		tempflex1		local
flex		tempflex2		local
vector		tempvector1		local
vector		tempvector2		local
vector		tempvector3		local
vector		tempvector4		local
flex		disttotarg		local
int			mode			local
flex		dot				local
flex		choice			local
flex		damage			local
int			damagetype		local
thing		damager			local
sector		cursector		local
int			forcemode		local
int			bot_keys		local
thing		item			local
model		newitemmodel	local
int			itempriority	local
int			newitempriority	local
int			special			local
int			nextanim		local
thing		potential		local
int			obstructed		local
flex		timeout			local

end

# Code Section

code

startup:
	if (IsMulti() && !IsServer()) {
		// Server-only
		return;
	}

	// Allow other server-side cogs to discover this one by its type
	SendTrigger(-1, 1852000, 1020, GetSelfCog(), botid, -1);

	return;

pulse:
	if(!IsServer()) return;
	setpulse(0);
	forcemode = SendMessageEx(srv_force, user7, 1000, -1, -1, -1);
	SendTrigger(-1, 100000, botid, rbot, forcemode, -1); // request update
	call dodge;
	call move;
	syncthingpos(rbot);
	setpulse(0.1);
	return;

killed:
	if(!IsServer()) return;
	setpulse(0);
	StopThing(rbot);
	botmode=BitClear(botmode,0x10000); // bot no longer alive
	KillTimerEx(120); // stop checking for 'bot lost'
	KillTimerEx(300); // stop checking if bot is in a pit
	SendMessageEx(srv_force, user7, 3001, -1, -1, -1); // stop force powers
	ClearActorFlags(rbot, 0x80); // make sure bot is not invisible
	SendTrigger(-1, 1000, botid, getsenderref(), getsourceref(), rbot); // send trigger to startup cog to respawn new bot
	ReleaseThing(rbot);
	return;

damaged:
	if (!IsServer()) return;

	damage=GetParam(0);
	damagetype=GetParam(1);
	damager=getsourceref(); // projectile - attacker=GetThingParent()

	if (damager!= -1 && (GetThingType(GetThingParent(damager)) == 2 || GetThingType(GetThingParent(damager)) == 10)) // attacker is another bot or player
	{
		AiSetLookPos(rbot, getthingpos(GetThingParent(damager))); // briefly look at who damaged the bot
	}

	if (BitTest(damagetype,0x20)) // drowning
	{
		drowning=1;
		KillTimerEx(150); // disable any previous drowning timer
		SetTimerEx(7.0, 150, -1, -1);
		ReturnEx(damage);
		return;
	}

	if (curweap == 10 && BitTest(botmode,0x200000)) // bot has saber - check if it can block
	{
		// Check for saber blocking
		dot = ThingViewDot(rbot, getthingparent(damager));
		if ((BitTest(damagetype, 0x10) && dot > 0.9 && dot < 1.1 && difficulty < 2) || (BitTest(damagetype, 0x10) && dot > 0.5 && dot < 1.5 && difficulty < 4) || (BitTest(damagetype, 0x10) && dot > 0.3 && dot < 1.7)) // attacker has saber & bot is facing attacker
		{
			SendTrigger(-1, 2100, botid, rbot, -1, -1); // send trigger to client to play saber block animation
			ReturnEx(0);
			return;
		}
		if ((BitTest(damagetype, 0x2) && dot > 0.9 && dot < 1.1 && difficulty < 2) || (BitTest(damagetype, 0x2) && dot > 0.5 && dot < 1.5 && difficulty < 4) || (BitTest(damagetype, 0x2) && dot > 0.3 && dot < 1.7)) // attacked by energy weapon & bot is _mainly_ facing attacker
		{
			SendTrigger(-1, 2100, botid, rbot, getthingtemplate(damager), -1); // send trigger to play saber block animation & deflect projectile
			ReturnEx(0);
			return;
		}
	}

	// If team play is enabled, prevent friendly fire from teammates
	if (damager != rbot && BitTest(gamemode,0x8)) {
		if (GetThingType(GetThingParent(damager)) == 10 && GetPlayerTeam(GetThingParent(damager)) == team) {
			// Damaged by player on same team
			ReturnEx(0);
			return;
		}
		if (GetThingType(GetThingParent(damager)) == 2 && GetThingUserData(GetThingParent(damager)) == team) {
			// Damaged by bot on same team
			ReturnEx(0);
			return;
		}
	}

	// Force powers may reduce the damage
	damage = SendMessageEx(srv_force, user7, 3002, damage, damagetype, damager);

	// Shields may reduce the damage
	// TODO: This currently behaves a bit differently than the player shields - when a player
	// dips below 50 shields, the shields become less effective and the player starts taking
	// more health damage.  Bots, on the other hand, use up the shields completely before
	// taking any health damage.
	// Note: The 100003 trigger sent to srv2 is what actually reduces the bot's shield amount
	if (BitTest(damagetype,0x10)) // saber attack damage - combined health & shields
	{
		if (shields > 0) {
			// Split damage between shields and health
			damage = damage / 2;
			SendTrigger(-1, 100003, botid, damage, GetThingParent(damager),-1); // update srv2 with damage
			if (damage > shields) {
				damage = damage + damage - shields;
			} else {
				damage = 0;
			}
		}
	}
	else if (BitTest(damagetype,0x2) || BitTest(damagetype,0x4)) // Damage from energy or fire
	{
		if (shields > 0) {
			SendTrigger(-1, 100003, botid, damage, GetThingParent(damager), -1); // update srv2 with damage
			if (damage > shields) {
				damage = damage - shields;
			} else {
				damage = 0;
			}
		}
	}

	if (damage > GetThingHealth(rbot)) // if damage is going to kill bot - switch off checking routines
	{
		// make sure bot dies
		SetThingHealth(rbot,1);
		StopThing(rbot); //Make 'em stay in place like when player dies [HR]
		ReturnEx(10);
		return;
	}

	// Return the modified damage value - this is how much health damage the bot will take
	ReturnEx(damage);
	return;

trigger:
	if (IsMulti() && !IsServer()) {
		// Server-only
		return;
	}

	if (GetSourceRef() == 1852000) {
		// Rbot cog type discovery
		if (GetParam(0) == 1021) {
			// rbot-srv2.cog
			if (GetParam(2) == botid) srv2 = GetParam(1);
		} else if (GetParam(0) == 1022) {
			// rbot-srv-force.cog
			if (GetParam(2) == botid) srv_force = GetParam(1);
		}
	}

	if (getsourceref() == 800) // game setup options <- obsolete
	{
		gamemode=getparam(0);
		difficulty=getparam(1);
		return;
	}
	if (GetSourceRef() == 11050) // Arrival event
	{
		if (GetParam(0) == arrival_event) {
			// This is the event we've been waiting for, so we can stop waiting now
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
	}
	if (getsourceref() == 12210) // updated CTF info
	{
		captured_red=GetParam(0);
		captured_gold=GetParam(1);
		redflag_taken=GetParam(2);
		goldflag_taken=GetParam(3);
	}
	if (getparam(0) != botid) return; // not for this bot

	if (getsourceref() == 900 && !BitTest(botmode,0x10000)) // respawn new bot && bot not already in-game and alive
	{
		botmode=0; // reset botmode
		botmode=BitSet(botmode,0x10000); // bot alive
		gamemode=GetParam(2);
		difficulty=GetParam(3);
		
		// initialization
		rbot=CreateThingNr(rtemp,getparam(1)); // create bot
		SendTrigger(-1,950,botid,rbot,botname,team); // Confirm botuid
		capturething(rbot);
		jkstringclear();
		jkStringConcatUNIString(1000+botname);
		jkStringConcatAsciiString(" respawns");
		jkStringOutput(-3,-1);
		node=-1;
		lastbotpos=GetThingPos(rbot);
		newpos='0 0 0';
		nodesize=0.25;
		lastposnum=-1;
		arrival_event=-1;
		prevnode=-1;
		lostcount=0;
		if (BitTest(characterflags,0x1)) botmode=BitSet(botmode,0x800000); // attack characteristic
		if (BitTest(characterflags,0x2)) botmode=BitSet(botmode,0x1000000); // defend characteristic
		if (BitTest(characterflags,0x4)) botmode=BitSet(botmode,0x2000000); // freelance characteristic
		SendTrigger(-1, 970, botid, rbot, botname, team); // return thing number
		SendMessageEx(srv_force, user7, 3000, -1, -1, -1); // start force powers
		SetTimerEx(0.1, 120, -1, -1); // start periodic check for 'bot lost' (short initial timeout makes bot ask for first node immediately)
		SetTimerEx(2.0, 300, -1, -1); // start periodic check if bot has fallen into a pit
		stopcount=0;
		allowdodge=1;
		setpulse(0.1);
	}
	else if (getsourceref() == 901) // remove bot from game
	{
		if (BitTest(botmode,0x10000)) // bot alive
		{
			jkstringclear();
			jkStringConcatUNIString(1000+botname);
			jkStringConcatAsciiString(" has left the game");
			jkStringOutput(-3,-1);
			DamageThing(rbot,500,1,rbot); // Make sure bot is dead
		}
	}
	else if (getsourceref() == 960 && BitTest(botmode,0x10000)) // query bot thing number and bot is alive
	{
		SendTrigger(-1, 970, botid, rbot, botname, team); // return thing number
	}
	else if (getsourceref() == 2100 && getparam(2) != -1) // Saber blocking projectiles
	{
		if (difficulty < 3) // test to see how random the blocked projectiles are
		{
			tempvector1=VectorSet((Rand()-0.5)*(5-difficulty), (Rand()-0.5)*(5-difficulty), 0.0);
		}
		else tempvector1=VectorSet(0.0, 0.0, 0.0);
		FireProjectile(rbot, getparam(2), -1, -1, '0.0135 0.1624 0.0', tempvector1, 1.0, 0x20, 30, 10); // make it random fire vector later
	}
	else if (getsourceref() == 11000) // New position available
	{
		node=getparam(1);
		nodesize = 0.25; // default size unless overridden
		if (node == -1) {
			// The nav cog couldn't find a suitable node for the bot, so have
			// the bot wander off in a random direction instead
			relpos = VectorScale(VectorNorm(VectorSet(Rand()-0.5, Rand()-0.5, 0)), 10);
			newpos = VectorAdd(GetThingPos(rbot), relpos);
			// Use shorter 'bot lost' timer so we check for nearby nodes more frequently
			KillTimerEx(120);
			SetTimerEx(3.0, 120, -1, -1);
		} else {
			// Head for the next node
			newpos = GetThingPos(node);
			if (GetThingCollideSize(node) > 0.05) {
				// Custom node size has been specified
				nodesize = GetThingCollideSize(node);
			}
		}
		lastposnum=getparam(2);
		rundir=getparam(3);
		tempvector1 = VectorNorm(GetThingVel(rbot));
		tempvector2 = VectorNorm(VectorSub(newpos, GetThingPos(rbot)));
		// See if the bot is moving fast and needs to make a sharp turn
		if (VectorLen(GetThingVel(rbot)) > 0.5 && VectorDot(tempvector1, tempvector2) < 0.25) {
			// Move to self position to help slow down for sharp turns
			AiSetMovePos(rbot, GetThingPos(rbot));
		}
	}
	else if (getsourceref() == 11020) // Received special info
	{
		special = getparam(1);
		mode = GetParam(2);
		if (mode && ((BitTest(special, 0x4) && !BitTest(botmode, 0x1000)) || (BitTest(special, 0x8) && BitTest(botmode, 0x1000)))) {
			// Bot needs to jump
			if (!BitTest(botmode,0x4000)) AiSetLookPos(rbot, newpos); // bot has no target - look at newpos
			AiSetMovePos(rbot, VectorAdd(newpos, '0 0 0.25')); // Encourage the bot to move upward a bit so he doesn't drag/reattach to the ground
			AddThingVel(rbot, VectorScale(VectorNorm(VectorSub(newpos, GetThingPos(rbot))), 0.75)); // increase bot speed toward next node before jump
			ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '0 0 -90'), 2.0)); // force bot to jump
		}
		if (BitTest(special, 0x200)) {
			// Bot needs to run fast
			KillTimerEx(220);
			if (mode) {
				// Enable effect
				AddThingVel(rbot, VectorScale(GetThingVel(rbot), 4));

				if (mode == 2) {
					// Enable effect for short duration only
					SetTimerEx(3.0, 220, -1, -1);
				}
			} else {
				// Disable effect
				AiSetMoveSpeed(rbot, 2.0); // Return to normal move speed
			}
		}
	}
	else if (GetSourceRef() == 11040) // Wait for arrival
	{
		special = GetParam(1);
		timeout = GetParam(3);
		if (timeout > 0.0 && GetParam(2) != -1) {
			// Start waiting, if we're running in the right direction
			if ((BitTest(special, 0x1) && rundir == 1) || (BitTest(special, 0x2) && rundir == 0)) {
				arrival_event = GetParam(2);
				waitpos = GetThingPos(rbot); // Wait at current position

				// Extend the 'bot lost' timeout to allow enough time for the arrival event to occur
				KillTimerEx(120);
				SetTimerEx(timeout, 120, -1, -1);
			}
		} else {
			// Stop waiting
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
	}
	else if (getsourceref() == 100001) // New info available
	{
		target=getparam(1);
		botmode=getparam(2);
		curweap=getparam(3);
	}
	else if (getsourceref() == 100002) // New info available
	{
		shields=getparam(1);
	}
	else if (getsourceref() == 101000) // weapon changed
	{
		curweap=getparam(1);
	}
	else if (getsourceref() == 101020 && !firing) // weapon fired && not already
	{
		firing=1;
		curweap=getparam(1);
		mode=getparam(2);
		nextanim=getparam(3);

		// Bot accuracy		
		if (curweap == 3) // st-rifle is always inaccurate
		{
			tempvector1=VectorSet((Rand()-0.5)*5, (Rand()-0.5)*5, 0.0);
		}
		else if (difficulty < 3) // set accuracy based on difficulty
		{
			tempvector1=VectorSet((Rand()-0.5)*(4-difficulty),(Rand()-0.5)*(4-difficulty), 0);
		}
		else
		{
			tempvector1=VectorSet(0, 0, 0); // perfect accuracy
		}

		// Lead distance
		#if (difficulty == 4)
		#{
		#	// FIXME: projectile_weap00[curweap] does not retrieve the correct template (some weapons have two templates, so the index by weapon number is not accurate)
		#	dummyproj = FireProjectile(rbot, projectile_weap00[curweap], -1, -1, '0 0 0', '0 0 0', 1.0, 0, 0.0, 0.0);
		#	targetvel = GetThingVel(target);
		#	speed = VectorDist('0 0 0', VectorSub(GetThingVel(dummyproj), targetvel));
		#	DestroyThing(dummyproj);
		#	distance = VectorDist(GetThingPos(target), GetThingPos(rbot));
		#	time = distance / speed;
		#	AiSetLookPos(rbot, VectorAdd(GetThingPos(target), VectorScale(targetvel, time)));
		#}

		if (curweap == 1 && nextanim == 0) FireProjectile(rbot, projectile_weap01, -1, 8, '-0.02 0.03 0', '0 0 0', 1.0, 0, 0.0, 0.0); // fists
		else if (curweap == 1 && nextanim == 1) FireProjectile(rbot, projectile_weap01, -1, 18, '0.02 0.03 0', '0 0 0', 1.0, 0, 0.0, 0.0); // fists - alternate
		else if (curweap == 2) FireProjectile(rbot, projectile_weap02, -1, 8, '0.0135 0.1624 0.0', tempvector1, 1.0, 0x20, 30, 10); // bryar
		else if (curweap == 3) FireProjectile(rbot, projectile_weap03, -1, 8, '0.0168 0.1896 0.00', tempvector1, 1.0, 0, 0, 0); // st-rifle
		else if (curweap == 5) FireProjectile(rbot, projectile_weap05b, -1, 18, '0.0207 0.0888 0.00', tempvector1, 1.0, 0x20, 30, 20); // bowcaster
		else if (curweap == 6) FireProjectile(rbot, projectile_weap06, -1, 8, '0.0186 0.0102 0.00', tempvector1, 1.0, 0x30, 25, 10 ); // repeater
		else if (curweap == 7)
		{
			if (mode == 0) FireProjectile(rbot, projectile_weap07, -1, 18, '0.0214 0.15 0.00', tempvector1, 1.0, 0x20, 30, 10); // railgun
			else FireProjectile(rbot, projectile_weap07a, -1, 18, '0.0214 0.15 0.00', '0 0 0', 1.0, 0x20, 30, 10); // railgun - secondary fire
			ApplyForce(rbot, VectorScale(GetThingLVec(rbot), -40)); // Provide a kick backwards
		}
		else if (curweap == 8 && mode == 0) FireProjectile(rbot, projectile_weap08, -1, 16, '0 0.05 0.00', '0 0 0', 1.0, 0, 0.0, 0.0); // sequencer mine - explode now
		else if (curweap == 8 && mode == 1) FireProjectile(rbot, projectile_weap08a, -1, 16, '0 0.05 0.00', '0 0 0', 1.0, 0, 0.0, 0.0); // sequencer mine - explode on contact
		else if (curweap == 9)
		{
			if (mode == 0) FireProjectile(rbot, projectile_weap09, -1, 18, '0.02 0.15 0.0', tempvector1, 1.0, 0x20, 30, 5); // conc rifle
			else FireProjectile(rbot, projectile_weap09a, -1, 18, '0.02 0.15 0.0', tempvector1, 1.0, 0x20, 30, 5); // conc rifle - secondary fire
			ApplyForce(rbot, VectorScale(GetThingLVec(rbot), -80)); // Provide a kick backwards
		}
		else if (curweap == 10) // lightsaber
		{
			if (mode == 6) // Double swing slash
			{
				SetTimerEx(0.2, 200, -1, -1); // fire 1st swing after 0.2 secs
				SetTimerEx(0.3, 200, -1, -1); // fire 1st swing after 0.3 secs
				SetTimerEx(0.6, 201, -1, -1); // fire 2nd swing after 0.6 secs
				SetTimerEx(0.7, 201, -1, -1); // fire 2nd swing after 0.7 secs
			}
			else // Regular strike
			{
				SetTimerEx(0.2, 202, -1, -1); // fire 1st swing after 0.2 secs
				SetTimerEx(0.3, 202, -1, -1); // fire 1st swing after 0.3 secs
			}
		}
		firing=0;
	}
	return;

move:
	if (GetActorFlags(rbot) & 0x800) // bot blind
	{
		AiSetMovePos(rbot, blindvec); // move to a random position
		AiSetLookPos(rbot, blindvec); // look at the random position
		return;
	}
	if (BitTest(botmode,0x400000)) // bot is 'gripped', don't move
	{
		AiSetMovePos(rbot, getthingpos(rbot));
		return; 
	}

	// If the bot is not moving forward to the next node, there may be an obstruction blocking the way
	if (VectorDot(GetThingLVec(rbot), GetThingVel(rbot)) < 0.3) {
		// Bot is not moving forward, try to determine if it is truly obstructed
		obstructed = 1;
		if (GetThingFlags(rbot) & 0x2000000 && (VectorZ(GetThingPos(rbot)) - VectorZ(newpos)) > 0.25) {
			// Bot is underwater and is trying to swim down to the next node
			obstructed = 0;
		} else if (arrival_event != -1 && VectorDist(GetThingPos(rbot), waitpos) < 0.1) {
			// Bot is holding position while awaiting arrival
			obstructed = 0;
		} else if (VectorDist(GetThingPos(rbot), newpos) < (VectorDist(lastbotpos, newpos) - 0.05)) {
			// Bot is still advancing toward the next node, despite not moving "forward" (e.g. elevators)
			obstructed = 0;
		}

		if (obstructed && !(GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000)) {
			// Bot is obstructed but appears to be airborne (not on floor/thing or in water)
			// Players can't "jump" in the air, so bots shouldn't be able to, either
			obstructed = 0;
		}

		// TODO: Possible force field detection logic:
		//if (obstructed)
		//{
		//	for (index=0; index<GetSurfaceCount(); index=index+1)
		//	{
		//		if ((VectorDist(GetSurfaceCenter(index), GetThingPos(rbot)) < 0.3) && (GetSurfaceFlags(index) & 0x4000)) // close surface & magsealed - ie: forcefield
		//		{
		//			print("found force field!");
		//			obstructed=0;
		//			// TODO: do something about it
		//		}
		//	}
		//}

		// If the bot is obstructed for long enough, try to jump (or swim) up to get over the obstruction
		if (obstructed) {
			stopcount = stopcount + 1;
			if (stopcount > 20) {
				// Bot has not moved in several seconds, try to get over the obstruction
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '0 0 -90'), 3.0)); // force bot to jump
				stopcount = 0;
			}
		}
	}
	lastbotpos = GetThingPos(rbot);
	
	if (drowning) // Help bot from drowning
	{
		if (getthingflags(rbot) & 0x2000000) // bot is still underwater
		{
			if (GetHealth(rbot) < 70 || difficulty <2)
			{
				//print("drowning - moving up!");
				// work out a vector postion 0.5 above the bot
				tempvector1=VectorSet(VectorX(GetThingPos(rbot)),VectorY(GetThingPos(rbot)),VectorZ(GetThingPos(rbot))+0.5);
				if (!BitTest(botmode,0x4000)) AiSetLookPos(rbot, tempvector1); // bot has no target - look at new position
				AiSetMovePos(rbot, tempvector1); // move towards new position
				call checkspeed;
				return;
			}
		}
		else
		{
			drowning=0;
			KillTimerEx(150); // disable any previous drowning timer
		}
	}

	// Look for items and move to them
	newitem=-1; // Clear item target for all difficulty levels to prevent stale values
	if (difficulty > 1 && !BitTest(botmode, 0x4000000)) // only look if difficulty allows
	{
		bot_keys = SendMessageEx(srv2, user7, 1008, -1, -1, -1);
		if (BitTest(botmode,0x4000)) newitempriority=5; else newitempriority=-1; // bot has target - only pick up high priority items
		dot=100;
		item = FirstThingInView(rbot, 40 + 20 * (2+difficulty), 3, 0x020); // check if any items nearby
		while (item != -1)
		{
			// Find closest takable item that bot needs
			if (HasLos(rbot, item)) // bot can see it
			{
				newitemmodel=GetThingModel(item);
				itempriority=-1;

				// work out item priority
				if (newitemmodel==itemmodel13) // red flag
				{
					if (captured_red == 1) itempriority=10; // flag dropped
					if (team == 1) // bot on red team
					{
						if (captured_red == 0 && goldflag_taken == rbot) itempriority=10; // red flag home & bot has gold flag
					}
					else // gold team
					{
						if (captured_red == 0) itempriority=10; // red flag at base
					}
				}
				else if (newitemmodel==itemmodel14) // gold flag
				{
					if (captured_gold == 1) itempriority=10; // flag dropped
					if (team == 2) // bot on gold team
					{
						if (captured_gold == 0 && redflag_taken == rbot) itempriority=10; // gold flag home & bot has red flag
					}
					else // red team
					{
						if (captured_gold == 0) itempriority=10; // gold flag at base
					}
				}

				tempflex1=VectorDist(GetThingPos(rbot), GetThingPos(item));
				if (tempflex1 > 0.2 && tempflex1 < dot) // item is greater than 0.2 away and is closer than the last item checked
				{
					if (newitemmodel==itemmodel16 && !BitTest(bot_keys, 0x1)) itempriority=9; // CTF red key
					if (newitemmodel==itemmodel17 && !BitTest(bot_keys, 0x2)) itempriority=9; // CTF gold key
					if (newitemmodel==itemmodel10 && BitTest(botmode,0x400)) itempriority=8; // health
					if ((newitemmodel==itemmodel11 || newitemmodel==itemmodel12) && BitTest(botmode,0x800)) itempriority=7; // shield & full shield
					if ((newitemmodel==itemmodel0 && BitTest(botmode,0x1)) || (newitemmodel==itemmodel1 && BitTest(botmode,0x2)) || (newitemmodel==itemmodel2 && BitTest(botmode,0x4)) || (newitemmodel==itemmodel3 && BitTest(botmode,0x8)) || (newitemmodel==itemmodel4 && BitTest(botmode,0x10))) itempriority=6; // weapons
					if ((newitemmodel==itemmodel5 && BitTest(botmode,0x20)) || (newitemmodel==itemmodel6 && BitTest(botmode,0x40)) || (newitemmodel==itemmodel7 && BitTest(botmode,0x80)) || (newitemmodel==itemmodel8 && BitTest(botmode,0x100))) itempriority=5; // energy & power cells & rail dets
					if ((newitemmodel==itemmodel9 && BitTest(botmode,0x200)) || (GetItemFlags(item) & 4)) itempriority=4; // sequencers or backpack
				}

				if (itempriority > newitempriority) // higher priority
				{
					newitem=item;
					dot=tempflex1;
					newitempriority=itempriority;
				}
				else item = NextThingInView();
			}
			else item = NextThingInView();

		}
		if (newitem != -1)
		{
			if (!BitTest(botmode,0x4000)) AiSetLookPos(rbot, getthingpos(newitem)); // only look at new item if no target
			AiSetMovePos(rbot, getthingpos(newitem)); // move towards new item
			call checkspeed;
			KillTimerEx(120); // stop 'bot lost' timeout
			SetTimerEx(5.0, 120, -1, -1); // bot has 5 sec to reach item before it's 'lost'
			return;
		}
	}

	if (BitTest(botmode,0x4000)) // bot has target
	{
		if (!firing) AiSetLookPos(rbot, getthingpos(target));  // look at target if not already firing weapon
		if (goldflag_taken == rbot || redflag_taken == rbot || GetThingHealth(rbot)<30) call movenode; else call targettactics; // if bot has flag or is low on health keep moving
	}
	else
	{
		AiSetLookPos(rbot, newpos); // look at move position
		call movenode;
	}
	return;

movenode:
	if (arrival_event != -1) // bot is waiting, don't move
	{
		AiSetMovePos(rbot, waitpos);
		return; 
	}

	AiSetMovePos(rbot, newpos);

	// Call navigation cog for next move position
	if (VectorDist(GetThingPos(rbot), newpos) < nodesize)
	{
		if (node != -1) {
			if (prevnode != node) {
				// Bot has reached a new node, reset lost counter
				prevnode = node;
				lostcount = 0;
			}
			// Reset stopcount - we've reached the next node, so any further obstructions should be new ones
			stopcount = 0;
		}
		KillTimerEx(120); // reset 'bot lost' timeout
		SetTimerEx(8.0, 120, -1, -1); 
		SendTrigger(-1, 11010, botid, rbot, node, -1); // ask for special info on current pos
		if (rundir) botmode=BitClear(botmode,0x1000); else botmode=BitSet(botmode,0x1000); // remember run direction
		SendTrigger(-1, 10000, botid, rbot, botmode, lastposnum); // ask for new pos
	}
	else
	{
		call checkspeed;
		// Check if bot has fallen
		tempflex1=VectorZ(newpos);
		tempflex2=VectorZ(GetThingPos(rbot));
		if (node != -1 && (tempflex1 > tempflex2) && !(getthingflags(node) & 0x2000000)) // if new pos is higher than bot pos & new pos is not in water
		{
			tempvector1=VectorSet(0,0,VectorZ(newpos));
			tempvector2=VectorSet(0,0,VectorZ(GetThingPos(rbot)));

			tempvector3=VectorSet(VectorX(newpos),VectorY(newpos),0);
			tempvector4=VectorSet(VectorX(GetThingPos(rbot)),VectorY(GetThingPos(rbot)),0);

			if (VectorDist(tempvector1,tempvector2) > 0.85 || (VectorDist(tempvector1,tempvector2) > 0.4 && VectorDist(tempvector3,tempvector4) < 0.2)) // bot fallen
			{
				KillTimerEx(120); // stop 'bot lost' timeout
				SetTimerEx(0.1, 120, -1, -1); // force bot 'lost'
			}
		}
	}
	return;

dodge:
	// dodge projectiles
	if (!allowdodge || difficulty < 3 || (difficulty < 4 && (10*rand() > difficulty))) return; // Difficulty 0,1,2 will never dodge. Difficulty 3 will sometimes dodge. Difficulty 4 will always dodge.

	potential = FirstThingInView(rbot, 270, 0.8, 0x8); //Scan for projectiles to dodge (0x8)
	while(potential != -1) // make sure projectile is not from this bot and is valid
	{
		if (rbot != GetThingParent(potential) && (GetAttachFlags(rbot) & 1))
		{
			choice=rand();
			if (choice > 0.75)
			{
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '0 0 -90'), 2.0)); // jump
			}
			else if (choice > 0.30)
			{
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '-90 0 0'), 2.0)); // slide left
			}
			else
			{
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '90 0 0'), 2.0)); // slide right
			}
			allowdodge=0;
			SetTimerEx(0.4, 400, -1, -1); // allow to dodge projectiles again in 0.4 secs
		}
		potential = NextThingInView();
	}
	return;

targettactics:
	//******************Begin AI Tactics********************
	relpos=VectorSet(0.0, 0.0, VectorZ(GetThingPos(target))-VectorZ(GetThingPos(rbot))); // work out relative position of target to bot
	disttotarg=VectorDist(GetThingPos(rbot), GetThingPos(target));

	//Get the current weapon of our target
	if (GetThingType(target) == 2) // target is another bot
	{
		targweap=SendMessageEx(GetThingCaptureCog(target), user1, -1, -1, -1, -1);
	}
	else // target is a player
	{
		targweap=GetCurWeapon(target);
		if (targweap==11) targweap=10; // If player has saber, set it to 10 for simplicity
	}
	if ((curweap==2 && targweap > 2 && difficulty > 0) || ((targweap==7 || targweap==9) && curweap < 6 && difficulty > 1)) // Need a better weapon than bryar
	{
		call movenode; 
		return;
	}

	if ((vectorZ(relpos) > 1 && difficulty > 1) || (getthingflags(rbot) & 0x2000000)) // Can't fall down safely or Underwater, need to keep moving.
	{
		call movenode;
		return;
	}

	// If bot not close enough to target move towards it
	if (disttotarg > 0.4)
	{
		if (difficulty < 3)
		{
			AiSetMovePos(rbot, GetThingPos(target)); // move directly towards target
		}
		else 
		{
			if (rand() > 0.4)
			{
				AiSetMovePos(rbot, GetThingPos(target)); // move directly towards target
			}
			else
			{
				tempvector1=VectorSet(VectorX(GetThingPos(target))+(0.2-rand()*0.4),VectorY(GetThingPos(target)),VectorZ(GetThingPos(target)));
				AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
			}
		}
		//else // move towards where target is moving
		//{
		//	movepos=VectorNorm(VectorSub(VectorAdd(GetThingPos(target), VectorScale(GetThingVel(target), 0.4)), GetThingPos(rbot)));
		//	movevec=VectorSet(VectorX(movepos), VectorY(movepos), 0.0);
		//	AiSetMovePos(rbot, movevec);
		//}
	}
	else if (difficulty > 2) // sometimes move around target
	{
		if (rand() > 0.6)
		{
			tempvector1=VectorSet(VectorX(GetThingPos(target))+(0.3-rand()*0.6),VectorY(GetThingPos(target)),VectorZ(GetThingPos(target)));
			AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
		}
	}
	call checkspeed;
	return;

checkspeed:
	if (BitTest(botmode,0x100000) || difficulty < 1)
	{
		AiSetMoveSpeed(rbot,2.0); // make bot run at 'walk speed'
	}
	else
	{
		forcemode = SendMessageEx(srv_force, user7, 1000, -1, -1, -1);
		tempvector1=GetThingVel(rbot);
		tempvector2=VectorSet(VectorX(tempvector1),VectorY(tempvector1),0);
		if (BitTest(forcemode,0x01)) // force speed active
		{
			if (VectorLen(tempvector2) < 3.0) AddThingVel(rbot, VectorScale(tempvector2, 0.33)); // Attempt to increase bot speed
		}
		else
		{
			if (VectorLen(tempvector2) < 1.0) AddThingVel(rbot, VectorScale(tempvector2, 0.33)); // Attempt to increase bot speed
		}
	}
	return;

timer:
	if(!IsServer()) return;
	if (GetSenderId() == 120) // bot has not found its next node in time - bot lost
	{
		// Keep track of how long we're lost while not in combat or getting an item
		if (!BitTest(botmode, 0x4000) && newitem == -1) {
			lostcount = lostcount + 1;
			if (lostcount > 6) {
				// Bot might be stuck somewhere (in a pit/hole, behind a corner, under a non-crushing
				// elevator, etc.).  We don't want the bot to be stuck indefinitely, so kill it to
				// force a respawn (like a player using the "kill" command).
				DamageThing(rbot, 800, 0x1, rbot); // kill bot
				return;
			}
		}

		// Stop awaiting any pending arrival events
		arrival_event = -1;

		// Reset the 'bot lost' timeout
		KillTimerEx(120);
		SetTimerEx(8.0, 120, -1, -1);

		// Request new node
		if (rundir) botmode=BitClear(botmode,0x1000); else botmode=BitSet(botmode,0x1000); // remember run direction
		SendTrigger(-1, 10000, botid, rbot, botmode, -1);
	}
	else if (GetSenderId() == 150) // Drowning damage should be over by now
	{
		drowning=0;
	}
	else if (GetSenderId() == 200) // fire 1st swing saber projectile
	{
		AiSetLookPos(rbot, getthingpos(target));
		FireProjectile(rbot, projectile_weap00a, -1, -1, '0.0 0.0 0.0', '0 0 0', 1.0, 0x20, 30, 10);
	}
	else if (GetSenderId() == 201) // fire 2nd swing saber projectile
	{
		AiSetLookPos(rbot, getthingpos(target));
		FireProjectile(rbot, projectile_weap00a, -1, -1, '0 0 0', '0 0 0', 1.0, 0x20, 30, 10);
	}
	else if (GetSenderId() == 202) // fire swing saber projectile
	{
		AiSetLookPos(rbot, getthingpos(target));
		FireProjectile(rbot, projectile_weap00, -1, -1, '0 0 0', '0 0 0', 1.0, 0x20, 30, 10);
	}
	else if (GetSenderId() == 220) // reduce bot speed after temporary speed increase
	{
		AiSetMoveSpeed(rbot,2.0);
	}
	else if (GetSenderId() == 230) // choose random move direction (force blinded)
	{
		blindvec = VectorSet((Rand()-0.5)*5, (Rand()-0.5)*5, 0.0);
		if (GetActorFlags(rbot) & 0x800) SetTimerEx(3+rand()*5,230,-1,-1); // bot still blind
	}
	else if (GetSenderId() == 300) // check if bot has fallen into a pit
	{
		cursector=GetThingSector(rbot);
		if (BitTest(GetSectorFlags(cursector), 0x40)) // in pit
		{
			DamageThing(rbot,800,1,rbot); // kill bot
		}
		else SetTimerEx(2.0, 300, -1, -1); // schedule another check
	}
	else if (GetSenderId() == 400) // reset dodge timer
	{
		allowdodge=1;
	}
	return;

user0: // force powers against bot
	if(!IsServer()) return;
	// Delegate to rbot-srv-force.cog
	ReturnEx(SendMessageEx(srv_force, user0, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
	return;

user1:
	ReturnEx(curweap); // Current Weapon
	return;

// Execute public API function for this cog
// Param 0 = Function ID
// The remaining params will be processed according to the requested function
// For example, param1 might be an index into an array.
// Returns the function-specific result of the execution
user7:
	// Simple symbol value reads
	if (GetParam(0) == 1000) ReturnEx(botid);
	else if (GetParam(0) == 1001) ReturnEx(botname);
	else if (GetParam(0) == 1002) ReturnEx(team);
	else if (GetParam(0) == 1003) ReturnEx(botmode);
	else if (GetParam(0) == 1004) ReturnEx(gamemode);
	else if (GetParam(0) == 1005) ReturnEx(difficulty);
	else if (GetParam(0) == 1010) ReturnEx(target);
	else if (GetParam(0) == 1011) ReturnEx(newitem);
	else if (GetParam(0) == 1012) ReturnEx(node);
	else if (GetParam(0) == 1013) ReturnEx(rbot);
	else if (GetParam(0) == 1014) ReturnEx(curweap);
	else if (GetParam(0) == 1015) ReturnEx(targweap);
	else if (GetParam(0) == 1100) ReturnEx(srv2);
	else if (GetParam(0) == 1101) ReturnEx(srv_force);
	// Simple symbol value writes
	else if (GetParam(0) == 2003) botmode = GetParam(1);
	// Calculated values
	else if (GetParam(0) == 3000) {
		// Return reference to live bot thing, or -1 if dead
		if (BitTest(botmode, 0x10000)) {
			// Bot is alive, return thing number
			ReturnEx(rbot);
		} else {
			// Bot is dead, return -1 since thing number may or may not be the bot thing
			ReturnEx(-1);
		}
	}
	// Otherwise, report error
	else {
		jkStringClear();
		jkStringConcatFormattedInt(GetSenderRef(), "rbot-srv.cog :: ERROR :: Cog %d");
		jkStringConcatFormattedInt(GetParam(0), " has requested an invalid function ID, %d");
		jkStringOutput(-1, -1);
	}
	return;

end
