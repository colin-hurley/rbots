# Rbot Navigation Cog - Alpha 0.32
#
# Created by Raynar

flags=0x280

symbols

message		startup
message		trigger

# Pathnodes
thing		node0=-1
thing		node1=-1
thing		node2=-1
thing		node3=-1
thing		node4=-1
thing		node5=-1
thing		node6=-1
thing		node7=-1
thing		node8=-1
thing		node9=-1
thing		node10=-1
thing		node11=-1
thing		node12=-1
thing		node13=-1
thing		node14=-1
thing		node15=-1
thing		node16=-1
thing		node17=-1
thing		node18=-1
thing		node19=-1
thing		node20=-1
thing		node21=-1
thing		node22=-1
thing		node23=-1
thing		node24=-1
thing		node25=-1
thing		node26=-1
thing		node27=-1
thing		node28=-1
thing		node29=-1
thing		node30=-1
thing		node31=-1
thing		node32=-1
thing		node33=-1
thing		node34=-1
thing		node35=-1
thing		node36=-1
thing		node37=-1
thing		node38=-1
thing		node39=-1
thing		node40=-1
thing		node41=-1
thing		node42=-1
thing		node43=-1
thing		node44=-1
thing		node45=-1
thing		node46=-1
thing		node47=-1
thing		node48=-1
thing		node49=-1
thing		node50=-1
thing		node51=-1
thing		node52=-1
thing		node53=-1
thing		node54=-1
thing		node55=-1
thing		node56=-1
thing		node57=-1
thing		node58=-1
thing		node59=-1
thing		node60=-1
thing		node61=-1
thing		node62=-1
thing		node63=-1
thing		node64=-1
thing		node65=-1
thing		node66=-1
thing		node67=-1
thing		node68=-1
thing		node69=-1
thing		node70=-1
thing		node71=-1
thing		node72=-1
thing		node73=-1
thing		node74=-1
thing		node75=-1
thing		node76=-1
thing		node77=-1
thing		node78=-1
thing		node79=-1
thing		node80=-1
thing		node81=-1
thing		node82=-1
thing		node83=-1
thing		node84=-1
thing		node85=-1
thing		node86=-1
thing		node87=-1
thing		node88=-1
thing		node89=-1
thing		node90=-1
thing		node91=-1
thing		node92=-1
thing		node93=-1
thing		node94=-1
thing		node95=-1
thing		node96=-1
thing		node97=-1
thing		node98=-1
thing		node99=-1

# Path info
int		pathsize=10
int		numpaths=10
int		inf0=0x0
int		inf1=0x0
int		inf2=0x0
int		inf3=0x0
int		inf4=0x0
int		inf5=0x0
int		inf6=0x0
int		inf7=0x0
int		inf8=0x0
int		inf9=0x0

# Max nodes available per path
int		max0		local
int		max1		local
int		max2		local
int		max3		local
int		max4		local
int		max5		local
int		max6		local
int		max7		local
int		max8		local
int		max9		local

# Misc vars
flex	mindist		local
int		index		local
int		offset		local
int		index1		local
int		offset1		local
int		index2		local
int		offset2		local
int		busy=0		local
int		botid		local
thing	rbot		local
vector	botpos		local
int		botmode		local
int		lastposnum	local
int		nextposnum	local
thing	nextpos		local
thing	item		local
int		curpath		local
int		changepath	local
int		rundir		local
int		special		local

int		debug=0		local

end

# Code Section

code

startup:
	if(!IsServer()) return;
	// work out max number of positions per path
	for (index=0;index<numpaths;index=index+1)
	{
		max0[index]=pathsize-1;
		for (offset=pathsize-1;offset>=0;offset=offset-1)
		{
			if (node0[index*pathsize+offset]==-1) max0[index]=offset-1;
		}
	}
	setpulse(1.0);
	return;

trigger:
	if(!IsServer()) return;
	if (getsourceref() == 10000) // bot wants to know next location
	{
		if (busy)
		{
			SendTrigger(0, 10010, getparam(0), -1, -1, -1);
			return;
		}
		busy=1;
		botid=getparam(0);   // which bot requested the info
		rbot=getparam(1);
		botpos=getthingpos(getparam(1));  // current position of bot
		botmode=getparam(2); // botmode
		lastposnum=getparam(3);

		if (lastposnum == -1) // bot lost -  find closest pos
		{
			mindist=100;
			for (index=0;index < numpaths;index=index+1)
			{
				for (offset=0;offset<pathsize;offset=offset+1)
				{
					// Find closest position and make sure the bot can see it
					if ((VectorDist(botpos, GetThingPos(node0[index*pathsize+offset])) < mindist) && (HasLOS(rbot, node0[index*pathsize+offset]) == 1))
					{
						mindist=VectorDist(botpos, GetThingPos(node0[index*pathsize+offset]));
						nextpos=node0[index*pathsize+offset];
						nextposnum=index*pathsize+offset;
					}
				}
			}
		}
		else
		{
			// work out current path
			for (index1=numpaths;index1 > 0;index1=index1-1)
			{
				if (lastposnum < (pathsize*index1)) curpath=index1-1;
			}

			// Work out old run direction (rundir 0=backwards 1=forwards)
			if (BitTest(botmode,0x1000)) rundir=0; else rundir=1; // set run direction from botmode
			
			// Check for intersections
			changepath=0;
			for (index=0;index < numpaths;index=index+1)
			{
				if (index != curpath) // don't check the current route
				{
					for (offset=0;offset < max0[index]+1;offset=offset+1)
					{
						if (node0[lastposnum] == node0[index*pathsize+offset]) // found intersection
						{
							if (rand() > 0.5) 
							{
								changepath=1;
							}

							// if old position at end of path - change path regardless
							if (lastposnum == curpath*pathsize+max0[curpath])
							{
								changepath=1;
							}
							// if old position is start of path and rundir is backwards - change path regardless
							if (lastposnum == curpath*pathsize && rundir==0)
							{
								changepath=1;
							}
							// if newposition at end of path and only 1 direction - don't change path
							if (offset == max0[index] && BitTest(inf0[index],0x1))
							{
								changepath=0;
							}
							// if newposition at start of path and rundir is backwards and wants to change path - set rundir forwards
							if (offset == index*pathsize && rundir==0 && (changepath))
							{
								rundir=1;
							}

							if (changepath) // Change path
							{
								// if intersection is in the middle of a path randomly change directions after changing path
								if (offset != max0[index] && offset != index*pathsize)
								{
									if (rand() > 0.60) rundir=1; else rundir=0;
								}
								lastposnum=index*pathsize+offset;
								curpath=index;
								offset=max0[index]+1; // break out of loop
								index=numpaths; // break out of loop
							}
						}
					}
				}
			}
				
			// Check run direction
			if (BitTest(inf0[curpath],0x1)) // path only allows forward direction
			{
				rundir=1;
			}
			else
			{
				if ((lastposnum == curpath*pathsize) && rundir == 0 && changepath == 0)  // if oldposition at start of path and rundir is backwards - set rundir forwards
				{
					rundir=1;
				}
				else if (lastposnum == curpath*pathsize+max0[curpath] && rundir == 1 && changepath == 0) // if old position at end of path & is not an intersection - reverse run direction
				{
					rundir=0; // reverse direction
				}
				else if (rand() > 0.98) // randomly change run direction
				{
					rundir=1-rundir;
				}
			}
			if (rundir) // run forward
			{
				nextposnum=lastposnum+1;
				if (BitTest(inf0[curpath],0x2) && nextposnum > (curpath*pathsize+max0[curpath])) nextposnum=curpath*pathsize; // if path is looping and lastpos at end - loop to start
			}
			else // run backward
			{
				nextposnum=lastposnum-1;
				if (BitTest(inf0[curpath],0x2) && nextposnum < curpath*pathsize) nextposnum=curpath*pathsize+max0[curpath]; // if path is looping and lastpos at start - loop to end
			}
		}
		nextpos=node0[nextposnum];

		if (debug)
		{
			jkstringclear();
			jkStringConcatAsciiString("botid: ");
			jkStringConcatInt(botid);  
			jkStringConcatAsciiString(": last: ");
			jkStringConcatInt(lastposnum);  
			jkStringConcatAsciiString(" next: ");
			jkStringConcatInt(nextposnum);
			jkStringConcatAsciiString(" rundir: ");
			jkStringConcatInt(rundir);
			jkStringOutput();
		} 
		// send info to bot
		SendTrigger(0, 11000, botid, nextpos, nextposnum, rundir);
		busy=0;
	}
	return;

end


