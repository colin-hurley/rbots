# Rbot Server Cog - Primary AI (JK variant)
#
# Server-only
# Type ID: 1020
#
# Rbots originally created by Raynar
# Additional code by Hell Raiser

flags=0x40

symbols

message		startup
message		pulse
message		killed
message		damaged
message		blocked
message		trigger
message		timer
message		skill
message		user7

int			botid=0

int			botname=-1
int			botskinid=-1

int			teambotname=-1

# Game setup options - set from startup cog
#int			gamemode=0							local
int			difficulty=0						local

# Internal bot references
thing		rbot=-1								local
int			botmode								local
cog			system=-1							local
cog			srv_force=-1						local
cog			srv_weapons=-1						local
cog			botskin=-1							local
cog			spitem=-1							local
cog			nav=-1								local
cog			customizer=-1						local

# Respawn Effects
template	teleport_particles=+telesparks		local
sound		teleportsnd=ForceThrow01.WAV		local

# Special Effects
sound		bactaSnd=BactaUse01.WAV				local

# Misc
int			score=0								local
int			curteam								local
int			curbotname							local
cog			curbotskin=-1						local
thing		node								local
vector		waitpos								local
vector		lastbotpos							local
vector		newpos								local
int			nextposnum							local
vector		blindvec							local
# Which direction the bot is running
# 0 = backward
# 1 = forward
int			rundir								local
int			stopcount							local
int			lostcount							local
int			drowning							local
int			target_mask							local
int			allowdodge							local
int			arrival_event						local
int			maxthings							local

# This symbol contains the fall threshold for the bot.  If the Z coordinate of
# the bot's position drops below this value, then logic to check if the bot has
# fallen will be executed.  This enables a bot to navigate from a lower node to
# a higher node, such as going up an elevator shaft, without requiring any
# special workarounds (e.g. adding 'submerged' thing flag to high node, adding
# intermediate nodes for smaller height differences, etc.).  The bot will only
# be considered fallen if it actually reaches some height and then falls back
# down.
flex		fallcheck							local

# This flag is set when the bot should jump at the next opportunity.
int			jump								local

# The target (bot or player) that this bot is trying to attack
thing		target=-1							local

# The bot or actor that most recently damaged the bot
thing		attacker=-1							local

# The item (powerup) that his bot is trying to collect
thing		item=-1								local

# Item templates
template	tmp_bacta=BACTATANK					local
template	tmp_health=HEALTHPACK				local
template	tmp_shields=SHIELDRECHARGE			local
template	tmp_supershield=SUPERSHIELD			local
template	tmp_fullshield=FULLSHIELD			local
template	tmp_revivepack=REVIVEPACK			local
template	tmp_backpack=+backpack				local

# Inventory items
int			shields								local
int			inv_bacta							local
int			inv_keys=0							local

# Transient working vars
vector		relpos								local
flex		tempflex1							local
flex		tempflex2							local
vector		tempvector1							local
vector		tempvector2							local
vector		tempvector3							local
vector		tempvector4							local
flex		dist								local
int			mode								local
flex		choice								local
flex		damage								local
int			damagetype							local
thing		damager								local
thing		killer								local
int			extra								local
sector		cursector							local
int			priority							local
int			itempriority						local
int			targetpriority						local
int			special								local
thing		potential							local
int			obstructed							local
flex		timeout								local
int			reachednode							local
int			targetok							local
thing		spawnpoint							local
thing		backpack							local
flex		movespeed							local

end

# Code Section

code

startup:
	if (IsMulti() && !IsServer()) return; // Host only

	// Allow other server-side cogs to discover this one by its type
	SendTrigger(-1, 1852000, 1020, GetSelfCog(), botid, -1);

	maxthings = GetThingCount(); // work out how many objects in the level
	target_mask = 0x404; // Attack both actors and players by default
	botmode = 0x80000; // bot disabled
	return;

pulse:
	if (IsMulti() && !IsServer()) return; // Host only
	if (!(GetDebugModeFlags() & 0x1 || AIGetMode(rbot) & 0x2000 || GetActorFlags(rbot) & 0x200000)) // bot AI is not disabled or frozen
	{
		call findtarget;
		call finditem;
		call checkitems;
		call checknode;
		call move;
		call checkspeed;
		call checkinventory;
	}
	SendMessageEx(srv_weapons, user7, 10233000, -1, -1, -1); // AI pulse
	SendMessageEx(srv_force, user7, 10223000, -1, -1, -1); // AI pulse
	SyncThingPos(rbot);
	return;

killed:
	if (IsMulti() && !IsServer()) return; // Host only
	killer = GetSourceRef();
	StopThing(rbot);
	backpack = CreateThingNr(tmp_backpack, rbot); // create backpack
	SendMessageEx(GetThingClassCog(backpack), user7, 10502010, backpack, rbot, -1); // fill backpack

	// Tell other srv cogs that the bot died
	SendMessageEx(srv_force, user7, 10223006, -1, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233006, -1, -1, -1);

	call stop_bot_ai;

	SendTrigger(-1, 960, rbot, killer, -1, -1); // send bot died event
	SetTimerEx(5.0, 100, -1, -1); // respawn bot after a few seconds
	return;

damaged:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetThingHealth(rbot) <= 0) return; // bot already dead

	damage = GetParam(0);
	damagetype = GetParam(1);
	damager = GetSourceRef(); // projectile - attacker=GetThingParent()

	if (BitTest(damagetype, 0x20)) drowning = 1;

	// Give saber a chance to block the damage
	damage = SendMessageEx(srv_weapons, damaged, damage, damagetype, damager, -1);

	// Force powers may reduce the damage
	damage = SendMessageEx(srv_force, damaged, damage, damagetype, damager, -1);

	// Shields may reduce the damage
	// TODO: This currently behaves a bit differently than the player shields - when a player
	// dips below 50 shields, the shields become less effective and the player starts taking
	// more health damage.  Bots, on the other hand, use up the shields completely before
	// taking any health damage.
	if (BitTest(damagetype, 0x10)) // saber attack damage - combined health & shields
	{
		// Split damage between shields and health
		damage = damage / 2;
		if (damage > shields)
		{
			damage = damage + damage - shields;
			shields = 0;
		}
		else
		{
			shields = shields - damage;
		}
	}
	if (BitTest(damagetype, 0x2) || BitTest(damagetype, 0x4)) // Damage from energy or fire
	{
		if (damage > shields)
		{
			damage = damage - shields;
			shields = 0;
		}
		else
		{
			shields = shields - damage;
			damage = 0;
		}
	}

	// If team play is enabled, prevent friendly fire from teammates
	// Note: Only damage to health is prevented; friendly fire still drains shields and force armor even for players
	if (rbot != damager && rbot != GetThingParent(damager) && curteam != 0 && (GetMultiModeFlags() & 0x1) && (GetMultiModeFlags() & 0x2)) // team play and no damage to teammates
	{
		if (GetThingType(GetThingParent(damager)) == 10 && GetPlayerTeam(GetThingParent(damager)) == curteam)
		{
			// Damaged by player on same team
			ReturnEx(0);
			return;
		}
		if (GetThingType(GetThingParent(damager)) == 2 && GetThingUserData(GetThingParent(damager)) == curteam)
		{
			// Damaged by bot on same team
			ReturnEx(0);
			return;
		}
	}

	if (damager != -1 && damager != rbot && GetThingParent(damager) != rbot && (GetThingType(GetThingParent(damager)) == 2 || GetThingType(GetThingParent(damager)) == 10)) // attacker is another bot or player
	{
		attacker = GetThingParent(damager);
		KillTimerEx(170);
		SetTimerEx(2.0, 170, -1, -1); // forget who damaged the bot after 2.0 secs if no further damage or blocking
	}

	// Return the modified damage value - this is how much health damage the bot will take
	ReturnEx(damage);
	return;

blocked:
	if (attacker != -1 && HasLOS(rbot, attacker) && ThingViewDot(rbot, attacker) > 0.8)
	{
		// We cannot tell for certain that the bot is blocking the attacker right now
		// But since we know the attacker is still in front of the bot, it is a good chance
		// So extend the timer so the bot continues to face the current attacker
		KillTimerEx(170);
		SetTimerEx(2.0, 170, -1, -1); // forget who damaged the bot after 2.0 secs if no further damage or blocking
	}
	SendMessageEx(srv_weapons, blocked, -1, -1, -1, -1);
	return;

trigger:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetSourceRef() == 1852000) // Rbot cog type discovery
	{
		if (GetParam(0) == 1010) // rbot-startup.cog
		{
			system = GetParam(1);
		}
		if (GetParam(0) == 1022) // rbot-srv-force.cog
		{
			if (GetParam(2) == botid) srv_force = GetParam(1);
		}
		if (GetParam(0) == 1023) // rbot-srv-weapons.cog
		{
			if (GetParam(2) == botid) srv_weapons = GetParam(1);
		}
		if (GetParam(0) == 1030) // rbot-skin.cog
		{
			if (GetParam(2) == botskinid) botskin = GetParam(1);
		}
		if (GetParam(0) == 1041) // rbot-item-special.cog
		{
			spitem = GetParam(1);
		}
		if (GetParam(0) == 1060) // rbot-nav.cog
		{
			nav = GetParam(1);
		}
		if (GetParam(0) == 3000) // Customizer module (e.g. CTF, KFY)
		{
			customizer = GetParam(1);
		}
		return;
	}

	if (GetSourceRef() == 800) // game setup options
	{
		#gamemode = GetParam(0);
		difficulty = GetParam(1);
		return;
	}

	if (GetSourceRef() == 11050) // Arrival event
	{
		if (GetParam(0) == arrival_event)
		{
			// This is the event we've been waiting for, so we can stop waiting now
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
		return;
	}

	if (GetSourceRef() == 120000) // Update target mask
	{
		if (GetParam(0))
		{
			target_mask = BitSet(target_mask, 0x400); // Attack players
		}
		else
		{
			target_mask = BitClear(target_mask, 0x400); // Ignore players
		}
		if (GetParam(1))
		{
			target_mask = BitSet(target_mask, 0x4); // Attack bots
		}
		else
		{
			target_mask = BitClear(target_mask, 0x4); // Ignore bots
		}
		return;
	}

	if (GetParam(0) != botid) return; // not for this bot

	if (GetSourceRef() == 11020) // Received special info
	{
		special = GetParam(1);
		mode = GetParam(2);
		if (BitTest(special, 0x2)) // Bot needs to walk instead of running
		{
			KillTimerEx(130);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x100000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(3.0, 130, -1, -1); // allow bot to run at full speed again after 5 secs
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x100000);
			}
		}
		if (mode && ((BitTest(special, 0x4) && rundir == 1) || (BitTest(special, 0x8) && rundir == 0))) // Bot needs to jump
		{
			jump = 1;
		}
		if (mode && ((BitTest(special, 0x20) && rundir == 1) || (BitTest(special, 0x40) && rundir == 0))) // Send activate to other cogs
		{
			SendTrigger(-1, 11030, botid, rbot, -1, -1); // Send "activate" trigger
		}
		if (BitTest(special, 0x80)) // Allow bot to walk off cliffs
		{
			KillTimerEx(150);
			if (mode) // Enable effect
			{
				AISetMode(rbot, 0x40); // Disable cliff checks

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 150, -1, -1); // restore cliff checks in a few seconds
				}
			}
			else // Disable effect
			{
				AIClearMode(rbot, 0x40); // Restore cliff checks
			}
		}
		if (BitTest(special, 0x100)) // Bot needs to crouch
		{
			KillTimerEx(190);
			if (mode) // Enable effect
			{
				SetPhysicsFlags(rbot, 0x10000); // start crouching

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 190, -1, -1); // stop crouching in a few seconds
				}
			}
			else // Disable effect
			{
				ClearPhysicsFlags(rbot, 0x10000); // stop crouching
			}
		}
		if (mode && BitTest(special, 0x200)) // Bot needs to run fast
		{
			// Add a burst of speed toward the next node
			tempvector1 = VectorNorm(VectorSub(newpos, GetThingPos(rbot)));
			AddThingVel(rbot, VectorScale(tempvector1, 2));
		}
		if (BitTest(special, 0x400)) // Disable item seeking, follow the path straight to the next node
		{
			KillTimerEx(180);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x4000000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 180, -1, -1); // allow bot to seek items again in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x4000000);
			}
		}
		if (BitTest(special, 0x800)) // Disable combat roaming, follow the path straight to the next node
		{
			KillTimerEx(181);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x8000000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 181, -1, -1); // allow bot to stray from the path during combat again in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x8000000);
			}
		}
		if (BitTest(special, 0x1000)) // Use lightsaber to slash open grate
		{
			KillTimerEx(182);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x4); // slash open grate

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(3.0, 182, -1, -1); // stop trying to slash open the grate in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x4); // slash open grate
			}
		}
		if (BitTest(special, 0x2000)) // Disable fall checking
		{
			KillTimerEx(183);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x8); // disable fall checking

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 183, -1, -1); // enable fall checking in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x8); // enable fall checking
			}
		}
		return;
	}

	if (GetSourceRef() == 11040) // Wait for arrival
	{
		special = GetParam(1);
		timeout = GetParam(3);
		if (timeout > 0.0 && GetParam(2) != -1)
		{
			// Start waiting, if we're running in the right direction
			if ((BitTest(special, 0x1) && rundir == 1) || (BitTest(special, 0x2) && rundir == 0))
			{
				arrival_event = GetParam(2);
				waitpos = GetThingPos(rbot); // Wait at current position

				// Extend the 'bot lost' timeout to allow enough time for the arrival event to occur
				KillTimerEx(120);
				SetTimerEx(timeout, 120, -1, -1);
			}
		}
		else
		{
			// Stop waiting
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
		return;
	}

	return;

timer:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetSenderId() == 100) // respawn bot
	{
		call respawn_bot;
		return;
	}

	if (GetSenderId() == 120) // bot has not found its next node in time - bot lost
	{
		// Keep track of how long we're lost while not in combat or getting an item
		if (target == -1 && item == -1)
		{
			lostcount = lostcount + 1;
			if (lostcount > 6)
			{
				// Bot might be stuck somewhere (in a pit/hole, behind a corner, under a non-crushing
				// elevator, etc.).  We don't want the bot to be stuck indefinitely, so kill it to
				// force a respawn (like a player using the "kill" command).
				ClearActorFlags(rbot, 0x8); // invulnerable
				DamageThing(rbot, 800, 0x1, rbot); // kill bot
				return;
			}
		}

		// Stop awaiting any pending arrival events
		arrival_event = -1;

		// Reset the 'bot lost' timeout
		KillTimerEx(120);
		SetTimerEx(8.0, 120, -1, -1);

		SendMessageEx(nav, user7, 10603000, rbot, -1, -1); // request navigation update
		return;
	}

	if (GetSenderId() == 130) // allow bot to run full speed again after slowdown
	{
		botmode = BitClear(botmode, 0x100000);
		return;
	}

	if (GetSenderId() == 140) // after supershield
	{
		ClearActorFlags(rbot, 8); // remove invulnerable
		ClearThingFlags(rbot, 4); // remove mag sealed
		return;
	}

	if (GetSenderId() == 150) // don't allow bot to walk off cliffs anymore
	{
		AIClearMode(rbot, 0x40); // Restore cliff checks
		return;
	}

	if (GetSenderId() == 160) // ask for high score
	{
		SendTrigger(-1, 101050, botid, -1, -1, -1); // ask for high scorer
		SetTimerEx(5.0, 160, -1, -1); // ask for high scorer every 5 secs
		return;
	}

	if (GetSenderId() == 170) // Forget who damaged bot
	{
		attacker = -1;
		return;
	}

	if (GetSenderId() == 180) // enable item seeking
	{
		botmode = BitClear(botmode, 0x4000000);
		return;
	}

	if (GetSenderId() == 181) // enable combat roaming
	{
		botmode = BitClear(botmode, 0x8000000);
		return;
	}

	if (GetSenderId() == 182) // stop trying to slash open grate with lightwaber
	{
		botmode = BitClear(botmode, 0x4); // slash open grate
		return;
	}

	if (GetSenderId() == 183) // allow bot to become lost after falling
	{
		botmode = BitClear(botmode, 0x8); // enable fall checking
		return;
	}

	if (GetSenderId() == 190) // stop crouching
	{
		ClearPhysicsFlags(rbot, 0x10000); // stop crouching
		return;
	}

	if (GetSenderId() == 230) // choose random move direction (force blinded)
	{
		relpos = VectorScale(VectorNorm(VectorSet(Rand()-0.5, Rand()-0.5, 0.0)), 10);
		blindvec = VectorAdd(GetThingPos(rbot), relpos);
		SetTimerEx(2 + 5*Rand(), 230, -1, -1); // schedule next blindvec update
		return;
	}

	if (GetSenderId() == 300) // check if bot has fallen into a pit
	{
		cursector = GetThingSector(rbot);
		if ((GetSectorFlags(cursector) & 0x40) && !(GetAttachFlags(rbot)) && VectorZ(GetThingVel(rbot)) < -3.0)
		{
			// Bot is aitborne and falling in a pit sector
			ClearActorFlags(rbot, 0x8); // invulnerable
			DamageThing(rbot, 800, 0x1, rbot); // kill bot
		}
		else SetTimerEx(1.0, 300, -1, -1); // schedule another check
		return;
	}

	if (GetSenderId() == 400) // reset dodge timer
	{
		allowdodge = 1;
		return;
	}

	if (GetSenderId() == 500) // bacta tank
	{
		botmode = BitClear(botmode, 0x2); // inventory cooldown
		if (inv_bacta > 0 && GetThingHealth(rbot) < 75) // has bacta, low health
		{
			PlaySoundThing(bactaSnd, rbot, 1.0, -1, -1, 128);
			HealThing(rbot, 30.0);
			inv_bacta = inv_bacta - 1;
		}
		return;
	}

	return;

skill:
	if (GetSenderType() == 3) // sender is a thing
	{
		// If the sender is a thing, that means we were called with SkillTarget().
		// Prepare to delegate to the other rbot-srv-*.cog files below.

		// We cannot set the sender/source with SendMessageEx(), so pass them as extra params instead.
		SetParam(2, GetSenderRef()); // victim
		SetParam(3, GetSourceRef()); // attacker
	}

	// If the 'bin' is >= 1000, it is a weapon effect
	if (GetParam(0) >= 1000)
	{
		// We cannot set the sender/source with SendMessageEx(), so pass them as extra params instead.
		// Note: Params 2 and 3 are unused for almost all weapon skill calls from LEC cogs, so we are not squashing any important params here.
		SetParam(2, GetSenderRef()); // the cog that sent this message
		SetParam(3, GetSourceRef()); // the player that sent this message
		// Delegate handling to rbot-srv-weapons.cog
		ReturnEx(SendMessageEx(srv_weapons, skill, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		return;
	}

	// If the 'bin' is < 1000, it is a force power
	// Delegate handling to rbot-srv-force.cog
	ReturnEx(SendMessageEx(srv_force, skill, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
	return;

// Execute public API function for this cog
// Param 0 = Function ID
// The remaining params will be processed according to the requested function
// For example, param1 might be an index into an array.
// Returns the function-specific result of the execution
user7:
	// Simple symbol value reads
	if (GetParam(0) == 10201000) { ReturnEx(botid); return; }
	if (GetParam(0) == 10201001) { ReturnEx(curbotname); return; }
	if (GetParam(0) == 10201002) { ReturnEx(curteam); return; }
	if (GetParam(0) == 10201003) { ReturnEx(botmode); return; }
	if (GetParam(0) == 10201004) { ReturnEx(score); return; }
	if (GetParam(0) == 10201010) { ReturnEx(target); return; }
	if (GetParam(0) == 10201011) { ReturnEx(item); return; }
	if (GetParam(0) == 10201012) { ReturnEx(node); return; }
	if (GetParam(0) == 10201013) { ReturnEx(rbot); return; }
	if (GetParam(0) == 10201021) { ReturnEx(shields); return; }
	if (GetParam(0) == 10201024) { ReturnEx(inv_bacta); return; }
	if (GetParam(0) == 10201028) { ReturnEx(inv_keys); return; }

	if (GetParam(0) == 10202028) { inv_keys = GetParam(1); return; }

	if (GetParam(0) == 10203002) // Change bot team
	{
		curteam = GetParam(1);
		SetThingUserData(rbot, curteam);
		return;
	}

	if (GetParam(0) == 10203004) // Add to score
	{
		score = score + GetParam(1);
		ReturnEx(score);
		return;
	}

	if (GetParam(0) == 10203100) // enable bot
	{
		if (BitTest(botmode, 0x80000)) // bot is disabled
		{
			curteam = GetParam(1);
			curbotskin = GetParam(2);

			if (curbotskin != -1) // bot has been assigned a team skin
			{
				curbotname = teambotname;
			}
			else // bot should use its own skin
			{
				curbotname = botname;
				curbotskin = botskin;
			}

			jkStringClear();
			jkStringConcatUNIString(1000 + curbotname);
			jkStringConcatAsciiString(" has joined the game");
			jkStringOutput(-3, -1);

			botmode = BitClear(botmode, 0x80000);
			score = 0; // reset score
			inv_keys = 0x0; // reset keys
			call respawn_bot;
			SendTrigger(-1, 970, botid, rbot, curbotname, curteam); // Send bot join event
		}
		return;
	}

	if (GetParam(0) == 10203101) // disable bot
	{
		if (!BitTest(botmode, 0x80000)) // bot is enabled
		{
			jkStringClear();
			jkStringConcatUNIString(1000 + curbotname);
			jkStringConcatAsciiString(" has left the game");
			jkStringOutput(-3, -1);

			SendTrigger(-1, 971, botid, rbot, curbotname, curteam); // Send bot leave event
			call destroy_bot;
			botmode = BitSet(botmode, 0x80000);
		}
		return;
	}

	if (GetParam(0) == 10203200) // Navigation update
	{
		node = GetParam(1);
		rundir = GetParam(2);
		nextposnum = GetParam(3);

		if (rundir) botmode = BitClear(botmode, 0x1000);
		else botmode = BitSet(botmode, 0x1000);

		if (node == -1)
		{
			// The nav cog couldn't find a suitable node for the bot, so have
			// the bot wander off in a random direction instead
			relpos = VectorScale(VectorNorm(VectorSet(Rand()-0.5, Rand()-0.5, 0)), 10);
			newpos = VectorAdd(GetThingPos(rbot), relpos);
			// Use shorter 'bot lost' timer so we check for nearby nodes more frequently
			KillTimerEx(120);
			SetTimerEx(3.0, 120, -1, -1);
		}
		else
		{
			// Head for the next node
			newpos = GetThingPos(node);
		}

		// Reset fall threshold - use bot's current position or node's position, whichever is lower
		fallcheck = VectorZ(GetThingPos(rbot)) - 0.25; // Slightly below bot's height
		if (VectorZ(newpos) < fallcheck) fallcheck = VectorZ(newpos);

		return;
	}

	// Pass-through functions
	// Automatically forward messages to subordinate srv cogs
	// This is a convenience to make it look like one uber srv cog from an API perspective
	if (GetParam(0) >= 10220000 && GetParam(0) <= 10229999)
	{
		ReturnEx(SendMessageEx(srv_force, user7, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		return;
	}
	if (GetParam(0) >= 10230000 && GetParam(0) <= 10239999)
	{
		ReturnEx(SendMessageEx(srv_weapons, user7, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		return;
	}

	// Report error if function ID does not match anything above
	jkStringClear();
	jkStringConcatFormattedInt(GetSenderRef(), "rbot-srv.cog :: ERROR :: Cog %d");
	jkStringConcatFormattedInt(GetParam(0), " has requested an invalid function ID, %d");
	jkStringOutput(-1, -1);
	return;

stop_bot_ai:
	SetPulse(0);
	KillTimerEx(100); // cancel any pending respawn
	KillTimerEx(160); // stop asking for high scorer
	KillTimerEx(120); // stop checking for 'bot lost'
	KillTimerEx(230); // stop periodic blindvec updates
	KillTimerEx(300); // stop checking if bot is in a pit
	KillTimerEx(500); // stop bacta tank usage

	// Stop AI processes in other srv cogs
	SendMessageEx(srv_force, user7, 10223007, -1, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233007, -1, -1, -1);
	return;

destroy_bot:
	call stop_bot_ai;

	// Destroy old dead bot
	if (rbot != -1)
	{
		SendTrigger(-1, 949, botid, rbot, -1, -1); // Dead bot thing is being removed
		DestroyThing(rbot);
		rbot = -1;
	}
	return;

respawn_bot:
	call destroy_bot;

	// Reinitialize to default bot state
	botmode = 0x0; // reset botmode
	node = -1;
	newpos = '0 0 0';
	nextposnum = -1;
	lastbotpos = '0 0 0';
	arrival_event = -1;
	lostcount = 0;
	stopcount = 0;
	drowning = 0;
	allowdodge = 1;
	fallcheck = 0;
	jump = 0;
	attacker = -1;
	shields = 100;
	inv_bacta = 0;

	// Create bot
	spawnpoint = SendMessageEx(system, user7, 10103200, curteam, -1, -1);
	rbot = SendMessageEx(curbotskin, user7, 10303000, spawnpoint, -1, -1);
	if (rbot == -1 || GetThingType(rbot) != 2) return; // bot creation failed, cogs may be misconfigured

	// Do respawn effects
	CreateThingAtPos(teleport_particles, GetThingSector(rbot), GetThingPos(rbot), '0 0 0');
	PlaySoundThing(teleportsnd, rbot, 1.0, -1, -1, 0x180);

	// Start bot AI processes, etc.
	SetThingClassCog(rbot, GetSelfCog());
	SetThingHealth(rbot, 100);
	SetThingUserData(rbot, curteam);
	SetActorFlags(rbot, 0x1000000); // fully damage other actors
	ClearActorFlags(rbot, 0x8); // remove invulnerable
	ClearThingFlags(rbot, 0x4); // remove mag sealed
	SetTimerEx(5.0, 160, -1, -1); // ask for high scorer every 5 secs
	SetTimerEx(0.1, 120, -1, -1); // start periodic check for 'bot lost' (short initial timeout makes bot ask for first node immediately)
	SetTimerEx(1.0, 230, -1, -1); // start periodic blindvec updates (i.e. random vector for blinded bots to move to)
	SetTimerEx(1.0, 300, -1, -1); // start periodic check if bot has fallen into a pit
	SetPulse(0.1);

	// Notify other cogs of bot respawn
	SendMessageEx(srv_weapons, user7, 10233005, rbot, curbotskin, -1);
	SendMessageEx(srv_force, user7, 10223005, rbot, curbotskin, -1);
	SendTrigger(-1, 950, botid, rbot, curbotname, curteam); // Send bot respawn event
	return;

findtarget:
	target = -1;
	targetpriority = 0;
	dist = 100;

	if (BitTest(botmode, 0x4)) return; // slash open grate (ignore targets)

	potential = FirstThingInView(rbot, 40 + 20 * (2+difficulty), 8.0, target_mask);
	while (potential != -1)
	{
		targetok = 1;
		if (GetMultiModeFlags() & 0x1 && curteam != 0) // team play - check if target is on our team
		{
			if (GetThingType(potential) == 2 && GetThingUserData(potential) == curteam) targetok = 0; // target is an actor and is on our team
			if (GetThingType(potential) == 10 && GetPlayerTeam(potential) == curteam) targetok = 0;   // target is a player and is on our team
		}
		if (GetThingFlags(potential) & 0x200) targetok = 0; // target is dead
		if (BitTest(GetSectorFlags(GetThingSector(potential)), 0x40)) targetok = 0; // target in pit

		if (targetok && potential != rbot && HasLOS(rbot, potential)) // target is still ok, is not itself and bot can see it
		{
			// Work out target priority
			priority = 3;

			tempflex1 = VectorDist(GetThingPos(rbot), GetThingPos(potential));
			if (tempflex1 < 1) priority = 6; // closer targets get higher priority

			if (potential == attacker) priority = 7; // whoever hurt the bot last

			// Give the other srv cogs a chance to adjust the priority
			priority = SendMessageEx(srv_force, user7, 10223030, potential, priority, -1);
			priority = SendMessageEx(srv_weapons, user7, 10233030, potential, priority, -1);

			// Also consult the customizer cog, if there is one
			if (customizer != -1) priority = SendMessageEx(customizer, user7, 30003030, rbot, potential, priority);

			// Look for the closest target among the highest seen priority
			if (priority > targetpriority || (priority == targetpriority && tempflex1 < dist))
			{
				target = potential;
				targetpriority = priority;
				dist = tempflex1;
			}
		}
		potential = NextThingInView();
	}

	// Tell the other srv cogs about the new target
	SendMessageEx(srv_force, user7, 10222010, target, -1, -1);
	SendMessageEx(srv_weapons, user7, 10232010, target, -1, -1);

	return;

finditem:
	item = -1;
	itempriority = 0;
	dist = 100;

	if (BitTest(botmode, 0x4)) return; // slash open grate (ignore items)

	if (difficulty < 2 || BitTest(botmode, 0x4000000)) return; // only look if difficulty allows and item seeking is not disabled

	if (target != -1) itempriority = 5; // bot has target - only pick up high priority items
	potential = FirstThingInView(rbot, 40 + 20 * (2+difficulty), 3, 0x020); // check if any items nearby
	while (potential != -1)
	{
		// Retrieve special info for this item
		special = 0x0;
		if (spitem != -1) special = SendMessageEx(spitem, user7, 10413000, potential, -1, -1);

		// Find closest takable item that bot needs
		tempflex1 = VectorDist(GetThingPos(rbot), GetThingPos(potential));
		tempflex2 = VectorZ(GetThingPos(potential)) - VectorZ(GetThingPos(rbot));
		if (tempflex2 < 0) tempflex2 = -tempflex2; // tempflex2 = abs(tempflex2)
		if (!BitTest(special, 0x1) && HasLOS(rbot, potential) && tempflex1 <= 2.0 && tempflex2 <= 0.4) // item is not ignored and bot can see it and is close enough and item not too high/low
		{
			// Work out item priority
			priority = -1;

			// Check for some standard items
			if (GetThingTemplate(potential) == tmp_health && GetThingHealth(rbot) < 50) priority = 8;
			if ((GetThingTemplate(potential) == tmp_shields && shields < 70) || (GetThingTemplate(potential) == tmp_fullshield && shields < 70)) priority = 7;
			if (GetThingTemplate(potential) == tmp_backpack) priority = 4;
			if (GetThingTemplate(potential) == tmp_bacta && inv_bacta < 2) priority = 3;

			// Give the other srv cogs a chance to adjust the priority
			priority = SendMessageEx(srv_force, user7, 10223010, potential, priority, -1);
			priority = SendMessageEx(srv_weapons, user7, 10233010, potential, priority, -1);

			// Also consult the customizer cog, if there is one
			if (customizer != -1) priority = SendMessageEx(customizer, user7, 30003010, rbot, potential, priority);

			// Look for the closest item among the highest seen priority
			if (priority > itempriority || (priority == itempriority && tempflex1 < dist))
			{
				item = potential;
				itempriority = priority;
				dist = tempflex1;
			}
		}
		potential = NextThingInView();
	}

	if (item != -1) botmode = BitSet(botmode, 0x1); // bot has left the path to seek items

	return;

checkitems:
	for (potential = 0 ; potential <= maxthings ; potential = potential + 1) // check every item
	{
		if (GetThingType(potential) == 5) // items
		{
			// Retrieve special info for this item
			special = 0x0;
			if (spitem != -1) special = SendMessageEx(spitem, user7, 10413000, potential, -1, -1);

			// If bot is close to item and it is available and it can be touched
			if ((VectorDist(GetThingPos(rbot), GetThingPos(potential)) < 0.3) && !(GetThingFlags(potential) & 0x80000) && GetCollideType(potential) != 0)
			{
				if (HasLOS(rbot, potential) || BitTest(special, 0x2)) // Bot can see item or LOS check is disabled
				{
					call pickupitem; // bot can see item - pick it up
				}
			}
		}
	}
	return;

pickupitem:
	// Consult the customizer cog, if there is one
	if (customizer != -1)
	{
		// Let the customizer cog try to handle pickup of this item first
		if (SendMessageEx(customizer, user7, 30003020, rbot, potential, -1))
		{
			// Item pickup was handled by the customizer cog
			// Stop here and do not execute the usual item pickup handling code
			// This enables the customizer to override the standard pickup behavior when needed
			return;
		}
	}

	if (GetThingTemplate(potential) == tmp_bacta)
	{
		if (inv_bacta < 5)
		{
			inv_bacta = inv_bacta + 1;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_health)
	{
		if (GetThingHealth(rbot) < 100)
		{
			extra = GetThingHealth(rbot) + 20;
			if (extra > 100) extra = 100;
			SetThingHealth(rbot, extra);
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_shields)
	{
		if (shields < 200)
		{
			shields = shields + 20;
			if (shields > 200) shields = 200;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_supershield)
	{
		shields = shields + 50;
		if (shields > 200) shields = 200;
		TakeItem(potential, rbot); // bot picked up this item
		SetActorFlags(rbot, 8); // invulnerable
		SetThingFlags(rbot, 4); // mag sealed
		KillTimerEx(140);
		SetTimerEx(30, 140, -1, -1); // switch off in 30 secs
		return;
	}

	if (GetThingTemplate(potential) == tmp_revivepack)
	{
		if (shields < 200 || GetThingHealth(rbot) < 100)
		{
			shields = 200;
			SetThingHealth(rbot, 100);
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_fullshield)
	{
		if (shields < 200)
		{
			shields = 200;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_backpack)
	{
		SendMessageEx(GetThingClassCog(potential), user7, 10502020, potential, rbot, -1);
		return;
	}

	// Give other srv cogs a chance to pickup the item
	SendMessageEx(srv_force, user7, 10223020, potential, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233020, potential, -1, -1);

	return;

checknode:
	// Check if bot got lost while seeking items
	if (node != -1 && item == -1 && BitTest(botmode, 0x1)) // seeking node, not seeking items, and previously left the path to seek items
	{
		botmode = BitClear(botmode, 0x1); // bot has left the path to seek items

		// Bot was seeking items but is now heading for the next node
		if (!HasLOS(rbot, node)) // bot no longer has LOS with the node
		{
			// Bot may not be able to get to the current node, so find the nearest node and continue from there
			KillTimerEx(120); // stop 'bot lost' timeout
			SetTimerEx(0.1, 120, -1, -1); // force bot 'lost'
		}
	}

	// Check our progress to the current node and request new node if necessary
	if (node != -1 && VectorDist(GetThingPos(rbot), GetThingPos(node)) < GetThingCollideSize(node))
	{
		reachednode = 1;
		if (node != -1) // Bot is heading for a node
		{
			// Reset lost counter to avoid unnecessary bot suicide
			lostcount = 0;

			// Reset stopcount - we've reached the next node, so any further obstructions should be new ones
			stopcount = 0;
		}
		KillTimerEx(120); // reset 'bot lost' timeout
		SetTimerEx(8.0, 120, -1, -1);
		SendTrigger(-1, 11010, botid, rbot, GetThingUserData(node), rundir); // ask for special info on current pos
		SendMessageEx(nav, user7, 10603000, rbot, nextposnum, -1); // request navigation update
	}
	else
	{
		reachednode = 0;
		tempflex1 = VectorZ(GetThingPos(rbot));
		tempflex2 = tempflex1 - 0.25;

		// Update the fall threshold
		if (fallcheck < tempflex2 || BitTest(botmode, 0x8)) // Bot is above the fall threshold or fall checking is disabled
		{
			fallcheck = tempflex2; // Move the fall threshold to slightly below the bot's current height
			if (fallcheck > VectorZ(newpos)) fallcheck = VectorZ(newpos); // But don't raise the threshold above the node's actual position
		}

		// Check if bot has fallen
		if (node != -1 && (tempflex1 < fallcheck) && !(GetThingFlags(node) & 0x2000000)) // if bot is below the fall threshold & new pos is not in water
		{
			tempvector1 = VectorSet(0, 0, VectorZ(newpos));
			tempvector2=VectorSet(0, 0, VectorZ(GetThingPos(rbot)));
			tempflex1 = VectorDist(tempvector1, tempvector2); // diff Z coord of bot and node

			tempvector3=VectorSet(VectorX(newpos), VectorY(newpos), 0);
			tempvector4=VectorSet(VectorX(GetThingPos(rbot)), VectorY(GetThingPos(rbot)), 0);
			tempflex2 = VectorDist(tempvector3, tempvector4); // diff X/Y coords of bot and node

			if (tempflex1 > 0.85 || (tempflex1 > 0.4 && tempflex2 < 0.2)) // bot fallen
			{
				KillTimerEx(120); // stop 'bot lost' timeout
				SetTimerEx(0.1, 120, -1, -1); // force bot 'lost'
			}
		}
	}
	return;

move:
	// By default, move normally to next node
	AiSetLookPos(rbot, newpos);
	AiSetMovePos(rbot, newpos);

	// Now check for exceptions to the normal movement behavior

	// Determine an appropriate minimum movement speed for the obstruction check
	tempflex1 = 0.3;
	if (IsThingCrouching(rbot)) tempflex1 = tempflex1 * 0.5;

	// If the bot is not moving forward to the next node, there may be an obstruction blocking the way
	obstructed = 0;
	if (VectorDot(GetThingLVec(rbot), GetThingVel(rbot)) < tempflex1)
	{
		// Bot is not moving forward, try to determine if it is truly obstructed
		obstructed = 1;

		if (VectorDist(GetThingPos(rbot), newpos) < (VectorDist(lastbotpos, newpos) - 0.05))
		{
			// Bot is still advancing toward the next node, despite not moving "forward" (e.g. elevators)
			obstructed = 0;
		}

		// TODO: Possible force field detection logic:
		//if (obstructed)
		//{
		//	for (index=0; index<GetSurfaceCount(); index=index+1)
		//	{
		//		if ((VectorDist(GetSurfaceCenter(index), GetThingPos(rbot)) < 0.3) && (GetSurfaceFlags(index) & 0x4000)) // close surface & magsealed - ie: forcefield
		//		{
		//			print("found force field!");
		//			obstructed=0;
		//			// TODO: do something about it
		//		}
		//	}
		//}
	}

	if (target != -1) // bot is attacking a target
	{
		call targettactics;
	}
	else if (attacker != -1) // bot has no target and is under attack
	{
		AiSetLookPos(rbot, GetThingPos(attacker));
	}

	if (item != -1)
	{
		if (target == -1 && attacker == -1) AiSetLookPos(rbot, GetThingPos(item)); // only look at new item if no target
		AiSetMovePos(rbot, GetThingPos(item)); // move towards new item
		// Reset the 'bot lost' timeout every pulse where the bot is going after an item
		// After reaching the item, bot has 5 sec to get back to the next node before 'bot lost'
		KillTimerEx(120); // Reset the 'bot lost' timeout
		SetTimerEx(5.0, 120, -1, -1);
	}

	if (GetActorFlags(rbot) & 0x800) // bot blind
	{
		AiSetMovePos(rbot, blindvec); // move to a random position
		AiSetLookPos(rbot, blindvec); // look at the random position
	}

	if (GetThingFlags(rbot) & 0x2000000) // bot is underwater
	{
		if ((VectorZ(GetThingPos(rbot)) - VectorZ(newpos)) > 0.25) obstructed = 0; // bot is trying to swim down to the next node

		if (drowning && (GetHealth(rbot) < 70 || difficulty < 2)) // Help bot from drowning
		{
			//print("drowning - moving up!");
			// work out a vector postion 0.5 above the bot
			tempvector1 = VectorAdd(GetThingPos(rbot), '0 0 0.5');
			if (target == -1) AiSetLookPos(rbot, tempvector1); // bot has no target - look at new position
			AiSetMovePos(rbot, tempvector1); // move towards new position
		}
	}
	else // bot is not underwater
	{
		drowning = 0; // bot is no longer drowning
	}

	if (arrival_event != -1) // bot is waiting, don't move
	{
		AiSetMovePos(rbot, waitpos);
		if (VectorDist(GetThingPos(rbot), waitpos) < 0.1) obstructed = 0; // Bot is holding position while awaiting arrival
	}

	if (GetActorFlags(rbot) & 0x40000) // bot is 'gripped', don't move
	{
		AiSetMovePos(rbot, GetThingPos(rbot));
		obstructed = 0; // do not attempt to jump over obstacles
	}

	call dodge;

	// If the bot is obstructed for long enough, try to jump (or swim) up to get over the obstruction
	if (obstructed)
	{
		stopcount = stopcount + 1;
		// Jump at some random delay after reaching the obstruction threshold
		// This encourages the bot to try slightly different timings for when it decides to jump
		if (stopcount > 20 && Rand() > 0.25)
		{
			// Bot has not moved in several seconds, try to get over the obstruction
			jump = 1;
			stopcount = 0;
		}
	}

	// Update lastbotpos for the next pulse
	lastbotpos = GetThingPos(rbot);

	// Check to see if bot needs to jump now
	// The bot can jump if he is on the ground or at the water surface
	// Players can't "jump" in the air, so bots shouldn't be able to, either
	// If underwater, the bot will "jump" by swimming upward a bit (this is to help get around underwater obstructions)
	if (jump && (GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000))
	{
		ApplyForce(rbot, VectorScale(VectorAdd(GetThingLVec(rbot), '0 0 90'), 2.5)); // jump
		jump = 0;
	}

	return;

targettactics:
	AiSetLookPos(rbot, GetThingPos(target));

	// Check to see if we can move toward the target

	if (GetThingHealth(rbot) < 30 || BitTest(botmode, 0x8000000)) return; // low on health or combat roaming is disabled

	tempflex1 = VectorZ(GetThingPos(target)) - VectorZ(GetThingPos(rbot)); // work out relative position of target to bot
	if (((tempflex1 < -1 || 1 < tempflex1) && difficulty >= 2) || (GetThingFlags(rbot) & 0x2000000)) return; // Can't fall down safely or Underwater

	// Consult the other srv cogs to see if the bot should move toward the target
	if (!SendMessageEx(srv_force, user7, 10223050, target, -1, -1)) return;
	if (!SendMessageEx(srv_weapons, user7, 10233050, target, -1, -1)) return;

	// Also consult the customizer cog, if there is one
	// Maintenance note: The two if-statements below are separated intentionally.
	// When combined, I found that the game would evaluate the expression to true
	// and execute the return statement even when customizer was -1.
	if (customizer != -1) if (!SendMessageEx(customizer, user7, 30003050, rbot, target, -1)) return;

	AiSetMovePos(rbot, GetThingPos(target)); // by default, move directly towards target

	dist = VectorDist(GetThingPos(rbot), GetThingPos(target));
	if (dist > 0.4) // too far away, try to close in on target
	{
		if (difficulty >= 3) // on higher difficulty
		{
			if (Rand() < 0.4) // sometimes move around target
			{
				tempvector1 = VectorScale(GetThingRVec(rbot), (Rand()-0.5) * 0.4); // random left/right offset
				tempvector1 = VectorAdd(GetThingPos(target), tempvector1); // target position + random left/right offset
				AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
			}
		}
		// TODO potential code to move where target is moving
		//	movepos = VectorNorm(VectorSub(VectorAdd(GetThingPos(target), VectorScale(GetThingVel(target), 0.4)), GetThingPos(rbot)));
		//	movevec = VectorSet(VectorX(movepos), VectorY(movepos), 0.0);
		//	AiSetMovePos(rbot, movevec);
	}
	else // close range
	{
		if (difficulty >= 2)
		{
			if (Rand() < 0.6) // sometimes move around target
			{
				tempvector1 = VectorScale(GetThingRVec(rbot), (Rand()-0.5) * 0.4); // random left/right offset
				tempvector1 = VectorAdd(GetThingPos(target), tempvector1); // target position + random left/right offset
				AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
			}
		}
	}

	return;

dodge:
	// dodge projectiles
	if (!allowdodge || difficulty < 3 || (difficulty < 4 && (10 * Rand() > difficulty))) return; // Difficulty 0,1,2 will never dodge. Difficulty 3 will sometimes dodge. Difficulty 4 will always dodge.

	potential = FirstThingInView(rbot, 180, 3, 0x8); // Scan for projectiles to dodge (0x8)
	while (potential != -1) // make sure projectile is not from this bot and is valid
	{
		if (rbot != GetThingParent(potential) && (GetAttachFlags(rbot) & 1))
		{
			choice = Rand();
			if (choice > 0.75)
			{
				jump = 1; // jump
			}
			else if (choice > 0.30)
			{
				ApplyForce(rbot, VectorScale(GetThingRVec(rbot), -180)); // slide left
			}
			else
			{
				ApplyForce(rbot, VectorScale(GetThingRVec(rbot), 180)); // slide right
			}
			allowdodge = 0;
			SetTimerEx(0.4, 400, -1, -1); // allow to dodge projectiles again in 0.4 secs
			return; // break -- don't execute multiple dodges in one pulse
		}
		potential = NextThingInView();
	}
	return;

checkspeed:
	if (reachednode) // Reached node this pulse
	{
		// See if bot is moving fast and needs to make a sharp turn
		tempvector1 = VectorNorm(GetThingVel(rbot));
		tempvector2 = VectorNorm(VectorSub(newpos, GetThingPos(rbot)));
		if (VectorLen(GetThingVel(rbot)) > 0.4 && VectorDot(tempvector1, tempvector2) < 0.7)
		{
			// If bot is not airborne, move to self position to help slow down for sharp turns
			// This check is necessary because telling an actor to move to its own position seems to
			// behave like StopThing and will reset vertical velocity like jumping and falling
			if (GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000)
			{
				AiSetMovePos(rbot, GetThingPos(rbot));
			}
		}
	}

	if ((GetPhysicsFlags(rbot) & 0x100000) || (GetThingFlags(rbot) & 0x2000000)) // bot is in water
	{
		// Normal player WASD swim speed is about 0.6 JKU/s
		// Combining WASD with jump/crouch boosts it to about 0.9 JKU/s
		// Use the difficulty to scale the movement speed according to these values
		// This emulates a more experienced player being able to swim faster and more efficiently
		movespeed = 0.5 + 0.4 * (difficulty / 4); // Range: [0.5,0.9]

		if (BitTest(botmode, 0x100000)) // move slowly
		{
			// Override for slow swim speed
			movespeed = 0.4;
		}
	}
	else // bot is on ground or in air
	{
		// Normal player WASD run speed is about 1.33 JKU/s
		movespeed = 1.33;

		// Surface drag reduces the bot speed from 1.33 to about 0.87
		// Scale the speed value to approximate player movement speed after reduction from drag
		// Magic number explanation: 0.87 * x = 1.33 --> x = 1.33 / 0.87 = 1.53
		// Plus a little extra because 1.53 only gets the bot up to about 1.2
		movespeed = movespeed * 1.6;

		if (IsThingCrouching(rbot)) // bot is crouching
		{
			// Normal player WASD crouch speed is about 0.26 JKU/s (0.13 JKU/s if moving backward)
			// Reduce bot speed if crouching
			movespeed = movespeed * 0.2;
		}
		else if (BitTest(botmode, 0x100000) || difficulty < 1) // move slowly or low difficulty
		{
			// Normal player WASD walk speed is about 0.66 JKU/s
			// Note that the bot will still use running animations even at this speed
			// The movespeed needs to be set around 0.5 or lower to switch to walking animations
			movespeed = movespeed * 0.5;
		}

		tempvector1 = GetThingVel(rbot);
		if (VectorLen(tempvector1) > 0.2) // bot is moving
		{
			tempvector1 = VectorNorm(tempvector1);
			tempvector2 = GetThingLVec(rbot);
			if (VectorDot(tempvector2, tempvector1) < -0.5) // bot is moving backward
			{
				// Reduce bot speed if moving backwards
				movespeed = movespeed * 0.5;
			}
		}

		if (!GetAttachFlags(rbot)) // bot is in the air
		{
			// Reduce bot maneuverability when in the air
			// We don't want the bot to have too much control while in the air
			// However, the effectiveness of some functions, such as obstruction jumps, depends
			// on the bot being able to accelerate forward while in the air, so we also don't
			// want to reduce this too much.
			movespeed = movespeed * 0.5;
		}
	}

	// allow srv-force to adjust movement speed (e.g. force speed)
	movespeed = SendMessageEx(srv_force, user7, 10223040, movespeed, -1, -1);

	AiSetMoveSpeed(rbot, movespeed);

	return;

checkinventory:
	if (difficulty < 1 || BitTest(botmode, 0x2)) return; // use items only if inventory allows and cooldown not in effect

	// See if we should use a bacta tank to heal
	if (inv_bacta > 0 && GetThingHealth(rbot) < 75)
	{
		botmode = BitSet(botmode, 0x2); // inventory cooldown
		// Simulate appropriate reaction speed - the higher the difficulty, the faster the bot will use the item
		tempflex1 = 0.1 + 2*(4-difficulty) + Rand()*2*(4-difficulty+1);
		SetTimerEx(tempflex1, 500, -1, -1);
		return;
	}

	return;

end
