# Rbot Server Cog - Primary AI
#
# Server-only
# Type ID: 1020
#
# Rbots originally created by Raynar
# Additional code by Hell Raiser

flags=0x40

symbols

message		startup
message		killed
message		pulse
message		trigger
message		timer
message		damaged
message		user7

int			botid=0

int			botname=-1
int			botskinid=-1

# Bot's team (only used in team play)
# 1 = red
# 2 = gold/yellow
# 3 = blue
# 4 = green
int			team=0
int			teambotname=-1
int			teambotskinid=-1

# Game setup options - set from startup cog
#int			gamemode=0							local
int			difficulty=0						local

# Internal bot references
thing		rbot=-1								local
int			botmode								local
cog			system=-1							local
cog			srv_ext=-1							local
cog			srv_force=-1						local
cog			srv_weapons=-1						local
cog			spitem=-1							local

# Respawn Effects
template	teleport_particles=+telesparks		local
sound		teleportsnd=ForceThrow01.WAV		local

# Misc
int			curteam								local
int			curbotname							local
int			curbotskinid						local
thing		node								local
sector		nodesec								local
flex		nodesize							local
int			nodeflags							local
vector		waitpos								local
vector		lastbotpos							local
vector		newpos								local
int			lastposnum							local
vector		blindvec							local
# Which direction the bot is running
# 0 = backward
# 1 = forward
int			rundir								local
int			stopcount							local
thing		prevnode							local
int			lostcount							local
int			drowning							local
int			target_mask							local
int			allowdodge							local
int			arrival_event						local
int			maxthings							local

# This symbol contains the fall threshold for the bot.  If the Z coordinate of
# the bot's position drops below this value, then logic to check if the bot has
# fallen will be executed.  This enables a bot to navigate from a lower node to
# a higher node, such as going up an elevator shaft, without requiring any
# special workarounds (e.g. adding 'submerged' thing flag to high node, adding
# intermediate nodes for smaller height differences, etc.).  The bot will only
# be considered fallen if it actually reaches some height and then falls back
# down.
flex		fallcheck							local

# This flag is set when the bot should jump at the next opportunity.
int			jump								local

# The target (bot or player) that this bot is trying to attack
thing		target=-1							local

# The bot or actor that most recently damaged the bot
thing		attacker=-1							local

# The item (powerup) that his bot is trying to collect
thing		item=-1								local

# Item templates
template	tmp_bacta=BACTATANK					local
template	tmp_health=HEALTHPACK				local
template	tmp_shields=SHIELDRECHARGE			local
template	tmp_supershield=SUPERSHIELD			local
template	tmp_fullshield=FULLSHIELD			local
template	tmp_revivepack=REVIVEPACK			local
template	tmp_backpack=+backpack				local

# Inventory items
int			shields								local
int			inv_bacta							local
int			inv_keys							local

# Transient working vars
vector		relpos								local
flex		tempflex1							local
flex		tempflex2							local
vector		tempvector1							local
vector		tempvector2							local
vector		tempvector3							local
vector		tempvector4							local
flex		dist								local
int			mode								local
flex		choice								local
flex		damage								local
int			damagetype							local
thing		damager								local
thing		killer								local
int			extra								local
sector		cursector							local
int			priority							local
int			itempriority						local
int			targetpriority						local
int			special								local
thing		potential							local
int			obstructed							local
flex		timeout								local
int			reachednode							local
int			targetok							local
thing		spawnpoint							local
thing		backpack							local
flex		movespeed							local

end

# Code Section

code

startup:
	if (IsMulti() && !IsServer()) return; // Host only

	// Allow other server-side cogs to discover this one by its type
	SendTrigger(-1, 1852000, 1020, GetSelfCog(), botid, -1);

	// Select skin, name, etc. depending on whether team play is active
	if (GetMultiModeFlags() & 0x1) // team play
	{
		// Team play
		curteam = team;
		curbotskinid = teambotskinid;
		curbotname = teambotname;
	}
	else
	{
		// Non-team play
		curteam = 0; // no team
		curbotskinid = botskinid;
		curbotname = botname;
	}

	maxthings = GetThingCount(); // work out how many objects in the level
	target_mask = 0x404; // Attack both actors and players by default
	botmode = 0x80000; // bot disabled
	return;

pulse:
	if (IsMulti() && !IsServer()) return; // Host only
	if (AIGetMode(rbot) & 0x2000) return; // bot AI disabled
	call findtarget;
	call finditem;
	call checkitems;
	call checknode;
	call move;
	call checkspeed;
	SyncThingPos(rbot);
	return;

killed:
	if (IsMulti() && !IsServer()) return; // Host only
	killer = GetSourceRef();
	StopThing(rbot);
	backpack = CreateThingNr(tmp_backpack, rbot); // create backpack

	// Tell other srv cogs that the bot died
	SendMessageEx(srv_force, user7, 10223006, backpack, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233006, backpack, -1, -1); // fill backpack with weapons and ammo

	call stop_bot_ai;

	SendTrigger(-1, 960, rbot, killer, -1, -1); // send bot died event
	SetTimerEx(5.0, 100, -1, -1); // respawn bot after a few seconds
	return;

damaged:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetThingHealth(rbot) <= 0) return; // bot already dead

	damage = GetParam(0);
	damagetype = GetParam(1);
	damager = GetSourceRef(); // projectile - attacker=GetThingParent()

	if (BitTest(damagetype, 0x20)) // drowning
	{
		drowning = 1;
		ReturnEx(damage);
		return;
	}

	// Give saber a chance to block the damage
	damage = SendMessageEx(srv_weapons, user7, 10233002, damage, damagetype, damager);

	// If team play is enabled, prevent friendly fire from teammates
	if (rbot != damager && rbot != GetThingParent(damager) && (GetMultiModeFlags() & 0x1) && (GetMultiModeFlags() & 0x2)) // team play and no damage to teammates
	{
		if (GetThingType(GetThingParent(damager)) == 10 && GetPlayerTeam(GetThingParent(damager)) == curteam)
		{
			// Damaged by player on same team
			ReturnEx(0);
			return;
		}
		if (GetThingType(GetThingParent(damager)) == 2 && GetThingUserData(GetThingParent(damager)) == curteam)
		{
			// Damaged by bot on same team
			ReturnEx(0);
			return;
		}
	}

	attacker = -1;
	if (damager != -1 && damager != rbot && GetThingParent(damager) != rbot && (GetThingType(GetThingParent(damager)) == 2 || GetThingType(GetThingParent(damager)) == 10)) // attacker is another bot or player
	{
		attacker = GetThingParent(damager);
		KillTimerEx(170);
		SetTimerEx(2.0, 170, -1, -1); // forget who damaged the bot after 2.0 secs if no further damage
	}

	// Force powers may reduce the damage
	damage = SendMessageEx(srv_force, user7, 10223002, damage, damagetype, damager);

	// Shields may reduce the damage
	// TODO: This currently behaves a bit differently than the player shields - when a player
	// dips below 50 shields, the shields become less effective and the player starts taking
	// more health damage.  Bots, on the other hand, use up the shields completely before
	// taking any health damage.
	if (BitTest(damagetype, 0x10)) // saber attack damage - combined health & shields
	{
		// Split damage between shields and health
		damage = damage / 2;
		if (damage > shields)
		{
			damage = damage + damage - shields;
			shields = 0;
		}
		else
		{
			shields = shields - damage;
		}
	}
	if (BitTest(damagetype, 0x2) || BitTest(damagetype, 0x4)) // Damage from energy or fire
	{
		if (damage > shields)
		{
			damage = damage - shields;
			shields = 0;
		}
		else
		{
			shields = shields - damage;
			damage = 0;
		}
	}

	if (damage > GetThingHealth(rbot)) // if damage is going to kill bot - switch off checking routines
	{
		// make sure bot dies
		SetThingHealth(rbot, 1);
		StopThing(rbot); //Make 'em stay in place like when player dies [HR]
		ReturnEx(10);
		return;
	}

	// Return the modified damage value - this is how much health damage the bot will take
	ReturnEx(damage);
	return;

trigger:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetSourceRef() == 1852000) // Rbot cog type discovery
	{
		if (GetParam(0) == 1010) // rbot-startup.cog
		{
			system = GetParam(1);
		}
		if (GetParam(0) == 1021) // rbot-srv-<ext>.cog
		{
			// The srv extension module (e.g. CTF, KFY)
			if (GetParam(2) == botid) srv_ext = GetParam(1);
		}
		if (GetParam(0) == 1022) // rbot-srv-force.cog
		{
			if (GetParam(2) == botid) srv_force = GetParam(1);
		}
		if (GetParam(0) == 1023) // rbot-srv-weapons.cog
		{
			if (GetParam(2) == botid) srv_weapons = GetParam(1);
		}
		if (GetParam(0) == 1041) // rbot-item-special.cog
		{
			// Store the reference with the lowest number - this is the first instance in the list
			if (GetParam(1) < spitem || spitem == -1) spitem = GetParam(1);
		}
		return;
	}

	if (GetSourceRef() == 800) // game setup options
	{
		#gamemode = GetParam(0);
		difficulty = GetParam(1);
		return;
	}

	if (GetSourceRef() == 11050) // Arrival event
	{
		if (GetParam(0) == arrival_event)
		{
			// This is the event we've been waiting for, so we can stop waiting now
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
		return;
	}

	if (GetSourceRef() == 120000) // Update target mask
	{
		if (GetParam(0))
		{
			target_mask = BitSet(target_mask, 0x400); // Attack players
		}
		else
		{
			target_mask = BitClear(target_mask, 0x400); // Ignore players
		}
		if (GetParam(1))
		{
			target_mask = BitSet(target_mask, 0x4); // Attack bots
		}
		else
		{
			target_mask = BitClear(target_mask, 0x4); // Ignore bots
		}
		return;
	}

	if (GetParam(0) != botid) return; // not for this bot

	if (GetSourceRef() == 101061) // new bot created
	{
		rbot = GetParam(1);
		return;
	}

	if (GetSourceRef() == 11020) // Received special info
	{
		special = GetParam(1);
		mode = GetParam(2);
		if (BitTest(special, 0x2)) // Bot needs to walk instead of running
		{
			KillTimerEx(130);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x100000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(3.0, 130, -1, -1); // allow bot to run at full speed again after 5 secs
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x100000);
			}
		}
		if (mode && ((BitTest(special, 0x4) && rundir == 1) || (BitTest(special, 0x8) && rundir == 0))) // Bot needs to jump
		{
			if (target == -1) AiSetLookPos(rbot, newpos); // bot has no target - look at newpos
			AiSetMovePos(rbot, VectorAdd(newpos, '0 0 0.25')); // Encourage the bot to move upward a bit so he doesn't drag/reattach to the ground
			if (GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000)
			{
				// Bot is on ground or in water, jump now
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '0 0 -90'), 2.5)); // force bot to jump
			}
			else
			{
				// Bot is airborne, set flag to jump at next opportunity
				jump = 1;
			}
		}
		if (mode && ((BitTest(special, 0x20) && rundir == 1) || (BitTest(special, 0x40) && rundir == 0))) // Send activate to other cogs
		{
			SendTrigger(-1, 11030, botid, rbot, -1, -1); // Send "activate" trigger
		}
		if (mode && BitTest(special, 0x200)) // Bot needs to run fast
		{
			// Add a burst of speed toward the next node
			tempvector1 = VectorNorm(VectorSub(newpos, GetThingPos(rbot)));
			AddThingVel(rbot, VectorScale(tempvector1, 2));
		}
		if (BitTest(special, 0x400)) // Disable item seeking, follow the path straight to the next node
		{
			KillTimerEx(180);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x4000000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 180, -1, -1); // allow bot to seek items again in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x4000000);
			}
		}
		if (BitTest(special, 0x800)) // Disable combat roaming, follow the path straight to the next node
		{
			KillTimerEx(181);
			if (mode) // Enable effect
			{
				botmode = BitSet(botmode, 0x8000000);

				if (mode == 2) // Enable effect for short duration only
				{
					SetTimerEx(5.0, 181, -1, -1); // allow bot to stray from the path during combat again in a few seconds
				}
			}
			else // Disable effect
			{
				botmode = BitClear(botmode, 0x8000000);
			}
		}
		return;
	}

	if (GetSourceRef() == 11040) // Wait for arrival
	{
		special = GetParam(1);
		timeout = GetParam(3);
		if (timeout > 0.0 && GetParam(2) != -1)
		{
			// Start waiting, if we're running in the right direction
			if ((BitTest(special, 0x1) && rundir == 1) || (BitTest(special, 0x2) && rundir == 0))
			{
				arrival_event = GetParam(2);
				waitpos = GetThingPos(rbot); // Wait at current position

				// Extend the 'bot lost' timeout to allow enough time for the arrival event to occur
				KillTimerEx(120);
				SetTimerEx(timeout, 120, -1, -1);
			}
		}
		else
		{
			// Stop waiting
			arrival_event = -1;

			// Resume the normal 'bot lost' timeout
			KillTimerEx(120);
			SetTimerEx(8.0, 120, -1, -1);
		}
		return;
	}

	if (GetSourceRef() == 13010) // New position available (1)
	{
		node = GetParam(1);
		nodesize = GetParam(2);
		rundir = GetParam(3);
		if (rundir) botmode = BitClear(botmode, 0x1000);
		else botmode = BitSet(botmode, 0x1000);
		return;
	}

	if (GetSourceRef() == 13011) // New position available (2)
	{
		if (node == -1)
		{
			// The nav cog couldn't find a suitable node for the bot, so have
			// the bot wander off in a random direction instead
			relpos = VectorScale(VectorNorm(VectorSet(Rand()-0.5, Rand()-0.5, 0)), 10);
			newpos = VectorAdd(GetThingPos(rbot), relpos);
			// Use shorter 'bot lost' timer so we check for nearby nodes more frequently
			KillTimerEx(120);
			SetTimerEx(3.0, 120, -1, -1);
		}
		else
		{
			// Head for the next node
			newpos = VectorSet(GetParam(1), GetParam(2), GetParam(3));
		}

		// Reset fall threshold - use bot's current position or node's position, whichever is lower
		fallcheck = VectorZ(GetThingPos(rbot)) - 0.25; // Slightly below bot's height
		if (VectorZ(newpos) < fallcheck) fallcheck = VectorZ(newpos);
		return;
	}

	if (GetSourceRef() == 13012) // New position available (3)
	{
		lastposnum = GetParam(1);
		nodesec = GetParam(2);
		nodeflags = GetParam(3);
		return;
	}

	return;

timer:
	if (IsMulti() && !IsServer()) return; // Host only

	if (GetSenderId() == 100) // respawn bot
	{
		call respawn_bot;
		return;
	}

	if (GetSenderId() == 120) // bot has not found its next node in time - bot lost
	{
		// Keep track of how long we're lost while not in combat or getting an item
		if (target == -1 && item == -1)
		{
			lostcount = lostcount + 1;
			if (lostcount > 6)
			{
				// Bot might be stuck somewhere (in a pit/hole, behind a corner, under a non-crushing
				// elevator, etc.).  We don't want the bot to be stuck indefinitely, so kill it to
				// force a respawn (like a player using the "kill" command).
				ClearActorFlags(rbot, 0x8); // invulnerable
				DamageThing(rbot, 800, 0x1, rbot); // kill bot
				return;
			}
		}

		// Stop awaiting any pending arrival events
		arrival_event = -1;

		// Reset the 'bot lost' timeout
		KillTimerEx(120);
		SetTimerEx(8.0, 120, -1, -1);

		// Request new node
		SendTrigger(-1, 13000, botid, rbot, botmode, -1);
		return;
	}

	if (GetSenderId() == 130) // allow bot to run full speed again after slowdown
	{
		botmode = BitClear(botmode, 0x100000);
		return;
	}

	if (GetSenderId() == 140) // after supershield
	{
		ClearActorFlags(rbot, 8); // remove invulnerable
		ClearThingFlags(rbot, 4); // remove mag sealed
		return;
	}

	if (GetSenderId() == 160) // ask for high score
	{
		SendTrigger(-1, 101050, botid, -1, -1, -1); // ask for high scorer
		SetTimerEx(5.0, 160, -1, -1); // ask for high scorer every 5 secs
		return;
	}

	if (GetSenderId() == 170) // Forget who damaged bot
	{
		attacker = -1;
		return;
	}

	if (GetSenderId() == 180) // enable item seeking
	{
		botmode = BitClear(botmode, 0x4000000);
		return;
	}

	if (GetSenderId() == 181) // enable combat roaming
	{
		botmode = BitClear(botmode, 0x8000000);
		return;
	}

	if (GetSenderId() == 230) // choose random move direction (force blinded)
	{
		relpos = VectorScale(VectorNorm(VectorSet(Rand()-0.5, Rand()-0.5, 0.0)), 10);
		blindvec = VectorAdd(GetThingPos(rbot), relpos);
		SetTimerEx(2 + 5*Rand(), 230, -1, -1); // schedule next blindvec update
		return;
	}

	if (GetSenderId() == 300) // check if bot has fallen into a pit
	{
		cursector = GetThingSector(rbot);
		if ((GetSectorFlags(cursector) & 0x40) && !(GetAttachFlags(rbot)) && VectorZ(GetThingVel(rbot)) < -3.0)
		{
			// Bot is aitborne and falling in a pit sector
			ClearActorFlags(rbot, 0x8); // invulnerable
			DamageThing(rbot, 800, 0x1, rbot); // kill bot
		}
		else SetTimerEx(1.0, 300, -1, -1); // schedule another check
		return;
	}

	if (GetSenderId() == 400) // reset dodge timer
	{
		allowdodge = 1;
		return;
	}

	return;

// Execute public API function for this cog
// Param 0 = Function ID
// The remaining params will be processed according to the requested function
// For example, param1 might be an index into an array.
// Returns the function-specific result of the execution
user7:
	// Simple symbol value reads
	if (GetParam(0) == 10201000) { ReturnEx(botid); return; }
	if (GetParam(0) == 10201001) { ReturnEx(curbotname); return; }
	if (GetParam(0) == 10201002) { ReturnEx(curteam); return; }
	if (GetParam(0) == 10201003) { ReturnEx(botmode); return; }
	if (GetParam(0) == 10201010) { ReturnEx(target); return; }
	if (GetParam(0) == 10201011) { ReturnEx(item); return; }
	if (GetParam(0) == 10201012)
	{
		if (GetParam(1) <= 0) { ReturnEx(node); return; }
		if (GetParam(1) == 1) { ReturnEx(VectorX(newpos)); return; }
		if (GetParam(1) == 2) { ReturnEx(VectorY(newpos)); return; }
		if (GetParam(1) == 3) { ReturnEx(VectorZ(newpos)); return; }
		if (GetParam(1) == 4) { ReturnEx(nodesec); return; }
	}
	if (GetParam(0) == 10201013) { ReturnEx(rbot); return; }
	if (GetParam(0) == 10201021) { ReturnEx(shields); return; }
	if (GetParam(0) == 10201024) { ReturnEx(inv_bacta); return; }
	if (GetParam(0) == 10201028) { ReturnEx(inv_keys); return; }

	if (GetParam(0) == 10202028) { inv_keys = GetParam(1); return; }

	if (GetParam(0) == 10203100) // enable bot
	{
		if (BitTest(botmode, 0x80000)) // bot is disabled
		{
			jkStringClear();
			jkStringConcatUNIString(1000 + curbotname);
			jkStringConcatAsciiString(" has joined the game");
			jkStringOutput(-3, -1);

			botmode = BitClear(botmode, 0x80000);
			call respawn_bot;
			SendTrigger(-1, 970, botid, rbot, curbotname, curteam); // Send bot join event
		}
		return;
	}

	if (GetParam(0) == 10203101) // disable bot
	{
		if (!BitTest(botmode, 0x80000)) // bot is enabled
		{
			jkStringClear();
			jkStringConcatUNIString(1000 + curbotname);
			jkStringConcatAsciiString(" has left the game");
			jkStringOutput(-3, -1);

			SendTrigger(-1, 971, botid, rbot, curbotname, curteam); // Send bot leave event
			call destroy_bot;
			botmode = BitSet(botmode, 0x80000);
		}
		return;
	}

	// Pass-through functions
	// Automatically forward messages to subordinate srv cogs
	// This is a convenience to make it look like one uber srv cog from an API perspective
	if (GetParam(0) >= 10210000 && GetParam(0) <= 10219999)
	{
		if (srv_ext != -1) ReturnEx(SendMessageEx(srv_ext, user7, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		else ReturnEx(-1);
		return;
	}
	if (GetParam(0) >= 10220000 && GetParam(0) <= 10229999)
	{
		ReturnEx(SendMessageEx(srv_force, user7, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		return;
	}
	if (GetParam(0) >= 10230000 && GetParam(0) <= 10239999)
	{
		ReturnEx(SendMessageEx(srv_weapons, user7, GetParam(0), GetParam(1), GetParam(2), GetParam(3)));
		return;
	}

	// Report error if function ID does not match anything above
	jkStringClear();
	jkStringConcatFormattedInt(GetSenderRef(), "rbot-srv.cog :: ERROR :: Cog %d");
	jkStringConcatFormattedInt(GetParam(0), " has requested an invalid function ID, %d");
	jkStringOutput(-1, -1);
	return;

stop_bot_ai:
	SetPulse(0);
	KillTimerEx(100); // cancel any pending respawn
	KillTimerEx(160); // stop asking for high scorer
	KillTimerEx(120); // stop checking for 'bot lost'
	KillTimerEx(230); // stop periodic blindvec updates
	KillTimerEx(300); // stop checking if bot is in a pit

	// Stop AI processes in other srv cogs
	SendMessageEx(srv_force, user7, 10223007, -1, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233007, -1, -1, -1);
	return;

destroy_bot:
	call stop_bot_ai;

	// Destroy old dead bot
	if (rbot != -1)
	{
		SendTrigger(-1, 949, botid, rbot, -1, -1); // Dead bot thing is being removed
		DestroyThing(rbot);
		rbot = -1;
	}
	return;

respawn_bot:
	call destroy_bot;

	// Reinitialize to default bot state
	botmode = 0x0; // reset botmode
	node = -1;
	newpos = '0 0 0';
	nodesec = 0;
	nodesize = 0.25;
	nodeflags = 0x0;
	lastposnum = -1;
	lastbotpos = '0 0 0';
	arrival_event = -1;
	prevnode = -1;
	lostcount = 0;
	stopcount = 0;
	drowning = 0;
	allowdodge = 1;
	fallcheck = 0;
	jump = 0;
	attacker = -1;
	shields = 100;
	inv_bacta = 0;
	inv_keys = 0x0;

	// Create bot
	rbot = -1;
	spawnpoint = SendMessageEx(system, user7, 10103200, curteam, -1, -1);
	SendTrigger(-1, 101060, curbotskinid, botid, spawnpoint, -1);
	if (rbot == -1) return; // bot creation failed, cogs may be misconfigured

	// Do respawn effects
	CreateThingAtPos(teleport_particles, GetThingSector(rbot), GetThingPos(rbot), '0 0 0');
	PlaySoundThing(teleportsnd, rbot, 1.0, -1, -1, 0x180);

	// Start bot AI processes, etc.
	SetThingClassCog(rbot, GetSelfCog());
	SetThingHealth(rbot, 100);
	SetThingUserData(rbot, curteam);
	SetActorFlags(rbot, 0x1000000); // fully damage other actors
	ClearActorFlags(rbot, 0x8); // remove invulnerable
	ClearThingFlags(rbot, 0x4); // remove mag sealed
	SetTimerEx(5.0, 160, -1, -1); // ask for high scorer every 5 secs
	SetTimerEx(0.1, 120, -1, -1); // start periodic check for 'bot lost' (short initial timeout makes bot ask for first node immediately)
	SetTimerEx(1.0, 230, -1, -1); // start periodic blindvec updates (i.e. random vector for blinded bots to move to)
	SetTimerEx(1.0, 300, -1, -1); // start periodic check if bot has fallen into a pit
	SetPulse(0.1);

	// Notify other cogs of bot respawn
	SendMessageEx(srv_weapons, user7, 10233005, rbot, curbotskinid, -1);
	SendMessageEx(srv_force, user7, 10223005, rbot, curbotskinid, -1);
	SendTrigger(-1, 950, botid, rbot, curbotname, curteam); // Send bot respawn event
	return;

findtarget:
	target = -1;
	targetpriority = 0;
	dist = 100;

	potential = FirstThingInView(rbot, 40 + 20 * (2+difficulty), 8.0, target_mask);
	while (potential != -1)
	{
		targetok = 1;
		if (GetMultiModeFlags() & 0x1) // team play - check if target is on our team
		{
			if (GetThingType(potential) == 2 && GetThingUserData(potential) == curteam) targetok = 0; // target is an actor and is on our team
			if (GetThingType(potential) == 10 && GetPlayerTeam(potential) == curteam) targetok = 0;   // target is a player and is on our team
		}
		if (GetThingFlags(potential) & 0x200) targetok = 0; // target is dead
		if (BitTest(GetSectorFlags(GetThingSector(potential)), 0x40)) targetok = 0; // target in pit

		if (targetok && potential != rbot && HasLOS(rbot, potential)) // target is still ok, is not itself and bot can see it
		{
			// Work out target priority
			priority = 3;

			tempflex1 = VectorDist(GetThingPos(rbot), GetThingPos(potential));
			if (tempflex1 < 1) priority = 6; // closer targets get higher priority

			if (potential == attacker) priority = 7; // whoever hurt the bot last

			// Give the other srv cogs a chance to adjust the priority
			if (srv_ext != -1) priority = SendMessageEx(srv_ext, user7, 10213030, potential, priority, -1);
			priority = SendMessageEx(srv_force, user7, 10223030, potential, priority, -1);
			priority = SendMessageEx(srv_weapons, user7, 10233030, potential, priority, -1);

			// Look for the closest target among the highest seen priority
			if (priority > targetpriority || (priority == targetpriority && tempflex1 < dist))
			{
				target = potential;
				targetpriority = priority;
				dist = tempflex1;
			}
		}
		potential = NextThingInView();
	}

	// Tell the other srv cogs about the new target
	SendMessageEx(srv_force, user7, 10222010, target, -1, -1);
	SendMessageEx(srv_weapons, user7, 10232010, target, -1, -1);

	return;

finditem:
	item = -1;
	itempriority = 0;
	dist = 100;

	if (difficulty < 2 || BitTest(botmode, 0x4000000)) return; // only look if difficulty allows and item seeking is not disabled

	if (target != -1) itempriority = 5; // bot has target - only pick up high priority items
	potential = FirstThingInView(rbot, 40 + 20 * (2+difficulty), 3, 0x020); // check if any items nearby
	while (potential != -1)
	{
		// Retrieve special info for this item
		special = 0x0;
		if (spitem != -1) special = SendMessageEx(spitem, user7, 10411000, potential, -1, -1);

		// Find closest takable item that bot needs
		tempflex1 = VectorDist(GetThingPos(rbot), GetThingPos(potential));
		tempflex2 = VectorZ(GetThingPos(potential)) - VectorZ(GetThingPos(rbot));
		if (tempflex2 < 0) tempflex2 = -tempflex2; // tempflex2 = abs(tempflex2)
		if (!BitTest(special, 0x1) && HasLOS(rbot, potential) && tempflex1 <= 2.0 && tempflex2 <= 0.4) // item is not ignored and bot can see it and is close enough and item not too high/low
		{
			// Work out item priority
			priority = -1;

			// Check for some standard items
			if (GetThingTemplate(potential) == tmp_health && GetThingHealth(rbot) < 50) priority = 8;
			if ((GetThingTemplate(potential) == tmp_shields && shields < 70) || (GetThingTemplate(potential) == tmp_fullshield && shields < 70)) priority = 7;
			if (GetThingTemplate(potential) == tmp_backpack) priority = 4;

			// Give the other srv cogs a chance to adjust the priority
			if (srv_ext != -1) priority = SendMessageEx(srv_ext, user7, 10213010, potential, priority, -1);
			priority = SendMessageEx(srv_force, user7, 10223010, potential, priority, -1);
			priority = SendMessageEx(srv_weapons, user7, 10233010, potential, priority, -1);

			// Look for the closest item among the highest seen priority
			if (priority > itempriority || (priority == itempriority && tempflex1 < dist))
			{
				item = potential;
				itempriority = priority;
				dist = tempflex1;
			}
		}
		potential = NextThingInView();
	}

	return;

checkitems:
	for (potential = 0 ; potential <= maxthings ; potential = potential + 1) // check every item
	{
		if (GetThingType(potential) == 5) // items
		{
			// Retrieve special info for this item
			special = 0x0;
			if (spitem != -1) special = SendMessageEx(spitem, user7, 10411000, potential, -1, -1);

			// If bot is close to item and it is available and it can be touched
			if ((VectorDist(GetThingPos(rbot), GetThingPos(potential)) < 0.3) && !(GetThingFlags(potential) & 0x80000) && GetCollideType(potential) != 0)
			{
				if (HasLOS(rbot, potential) || BitTest(special, 0x2)) // Bot can see item or LOS check is disabled
				{
					call pickupitem; // bot can see item - pick it up
				}
			}
		}
	}
	return;

pickupitem:
	if (GetThingTemplate(potential) == tmp_bacta)
	{
		if (inv_bacta < 5)
		{
			inv_bacta = inv_bacta + 1;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_health)
	{
		if (GetThingHealth(rbot) < 100)
		{
			extra = GetThingHealth(rbot) + 20;
			if (extra > 100) extra = 100;
			SetThingHealth(rbot, extra);
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_shields)
	{
		if (shields < 200)
		{
			shields = shields + 20;
			if (shields > 200) shields = 200;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_supershield)
	{
		shields = shields + 50;
		if (shields > 200) shields = 200;
		TakeItem(potential, rbot); // bot picked up this item
		SetActorFlags(rbot, 8); // invulnerable
		SetThingFlags(rbot, 4); // mag sealed
		KillTimerEx(140);
		SetTimerEx(30, 140, -1, -1); // switch off in 30 secs
		return;
	}

	if (GetThingTemplate(potential) == tmp_revivepack)
	{
		if (shields < 200 || GetThingHealth(rbot) < 100)
		{
			shields = 200;
			SetThingHealth(rbot, 100);
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_fullshield)
	{
		if (shields < 200)
		{
			shields = 200;
			TakeItem(potential, rbot); // bot picked up this item
		}
		return;
	}

	if (GetThingTemplate(potential) == tmp_backpack)
	{
		SendTrigger(-1, 12000, botid, potential, -1, -1); // send info to backpack cog
		TakeItem(potential, rbot); // bot picked up this item
		return;
	}

	// Give other srv cogs a chance to pickup the item
	if (srv_ext != -1) SendMessageEx(srv_ext, user7, 10213020, potential, -1, -1);
	SendMessageEx(srv_force, user7, 10223020, potential, -1, -1);
	SendMessageEx(srv_weapons, user7, 10233020, potential, -1, -1);

	return;

checknode:
	// Check our progress to the current node and request new node if necessary
	if (VectorDist(GetThingPos(rbot), newpos) < nodesize)
	{
		reachednode = 1;
		if (node != -1) // Bot is heading for a node
		{
			if (prevnode != node) // Bot has reached a new node
			{
				// Reset lost counter to avoid unnecessary bot suicide
				prevnode = node;
				lostcount = 0;
			}
			// Reset stopcount - we've reached the next node, so any further obstructions should be new ones
			stopcount = 0;
		}
		KillTimerEx(120); // reset 'bot lost' timeout
		SetTimerEx(8.0, 120, -1, -1); 
		SendTrigger(-1, 11010, botid, rbot, node, rundir); // ask for special info on current pos
		SendTrigger(-1, 13000, botid, rbot, botmode, lastposnum); // ask navigation cog for next move position
	}
	else
	{
		reachednode = 0;
		tempflex1 = VectorZ(GetThingPos(rbot));
		tempflex2 = tempflex1 - 0.25;

		// Update the fall threshold
		if (fallcheck < tempflex2) // Bot is above the fall threshold
		{
			fallcheck = tempflex2; // Raise the fall threshold to slightly below the bot's current height
			if (fallcheck > VectorZ(newpos)) fallcheck = VectorZ(newpos); // But don't raise the threshold above the node's actual position
		}

		// Check if bot has fallen
		if (node != -1 && (tempflex1 < fallcheck) && !BitTest(nodeflags, 0x2000000)) // if bot is below the fall threshold & new pos is not in water
		{
			tempvector1 = VectorSet(0, 0, VectorZ(newpos));
			tempvector2=VectorSet(0, 0, VectorZ(GetThingPos(rbot)));
			tempflex1 = VectorDist(tempvector1, tempvector2); // diff Z coord of bot and node

			tempvector3=VectorSet(VectorX(newpos), VectorY(newpos), 0);
			tempvector4=VectorSet(VectorX(GetThingPos(rbot)), VectorY(GetThingPos(rbot)), 0);
			tempflex2 = VectorDist(tempvector3, tempvector4); // diff X/Y coords of bot and node

			if (tempflex1 > 0.85 || (tempflex1 > 0.4 && tempflex2 < 0.2)) // bot fallen
			{
				KillTimerEx(120); // stop 'bot lost' timeout
				SetTimerEx(0.1, 120, -1, -1); // force bot 'lost'
			}
		}
	}
	return;

move:
	// By default, move normally to next node
	AiSetLookPos(rbot, newpos);
	AiSetMovePos(rbot, newpos);

	// Now check for exceptions to the normal movement behavior

	// If the bot is not moving forward to the next node, there may be an obstruction blocking the way
	obstructed = 0;
	if (VectorDot(GetThingLVec(rbot), GetThingVel(rbot)) < 0.3)
	{
		// Bot is not moving forward, try to determine if it is truly obstructed
		obstructed = 1;

		if (VectorDist(GetThingPos(rbot), newpos) < (VectorDist(lastbotpos, newpos) - 0.05))
		{
			// Bot is still advancing toward the next node, despite not moving "forward" (e.g. elevators)
			obstructed = 0;
		}

		// TODO: Possible force field detection logic:
		//if (obstructed)
		//{
		//	for (index=0; index<GetSurfaceCount(); index=index+1)
		//	{
		//		if ((VectorDist(GetSurfaceCenter(index), GetThingPos(rbot)) < 0.3) && (GetSurfaceFlags(index) & 0x4000)) // close surface & magsealed - ie: forcefield
		//		{
		//			print("found force field!");
		//			obstructed=0;
		//			// TODO: do something about it
		//		}
		//	}
		//}
	}

	if (target != -1) // bot is attacking a target
	{
		call targettactics;
	}
	else if (attacker != -1) // bot has no target and is under attack
	{
		AiSetLookPos(rbot, GetThingPos(attacker));
	}

	if (item != -1)
	{
		if (target == -1 && attacker == -1) AiSetLookPos(rbot, GetThingPos(item)); // only look at new item if no target
		AiSetMovePos(rbot, GetThingPos(item)); // move towards new item
		// Reset the 'bot lost' timeout every pulse where the bot is going after an item
		// After reaching the item, bot has 5 sec to get back to the next node before 'bot lost'
		KillTimerEx(120); // Reset the 'bot lost' timeout
		SetTimerEx(5.0, 120, -1, -1);
	}

	if (GetActorFlags(rbot) & 0x800) // bot blind
	{
		AiSetMovePos(rbot, blindvec); // move to a random position
		AiSetLookPos(rbot, blindvec); // look at the random position
	}

	if (GetThingFlags(rbot) & 0x2000000) // bot is underwater
	{
		if ((VectorZ(GetThingPos(rbot)) - VectorZ(newpos)) > 0.25) obstructed = 0; // bot is trying to swim down to the next node

		if (drowning && (GetHealth(rbot) < 70 || difficulty < 2)) // Help bot from drowning
		{
			//print("drowning - moving up!");
			// work out a vector postion 0.5 above the bot
			tempvector1 = VectorAdd(GetThingPos(rbot), '0 0 0.5');
			if (target == -1) AiSetLookPos(rbot, tempvector1); // bot has no target - look at new position
			AiSetMovePos(rbot, tempvector1); // move towards new position
		}
	}
	else // bot is not underwater
	{
		drowning = 0; // bot is no longer drowning
	}

	if (arrival_event != -1) // bot is waiting, don't move
	{
		AiSetMovePos(rbot, waitpos);
		if (VectorDist(GetThingPos(rbot), waitpos) < 0.1) obstructed = 0; // Bot is holding position while awaiting arrival
	}

	if (GetActorFlags(rbot) & 0x40000) // bot is 'gripped', don't move
	{
		AiSetMovePos(rbot, GetThingPos(rbot));
		obstructed = 0; // do not attempt to jump over obstacles
	}

	call dodge;

	// If the bot is obstructed for long enough, try to jump (or swim) up to get over the obstruction
	if (obstructed)
	{
		stopcount = stopcount + 1;
		// Jump at some random delay after reaching the obstruction threshold
		// This encourages the bot to try slightly different timings for when it decides to jump
		if (stopcount > 20 && Rand() > 0.25)
		{
			// Bot has not moved in several seconds, try to get over the obstruction
			jump = 1;
			stopcount = 0;
		}
	}

	// Update lastbotpos for the next pulse
	lastbotpos = GetThingPos(rbot);

	// Check to see if bot needs to jump now
	// The bot can jump if he is on the ground or at the water surface
	// Players can't "jump" in the air, so bots shouldn't be able to, either
	// If underwater, the bot will "jump" by swimming upward a bit (this is to help get around underwater obstructions)
	if (jump && (GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000))
	{
		ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '0 0 -90'), 2.5)); // jump
		jump = 0;
	}

	return;

targettactics:
	AiSetLookPos(rbot, GetThingPos(target));

	// Check to see if we can move toward the target

	if (GetThingHealth(rbot) < 30 || BitTest(botmode, 0x8000000)) return; // low on health or combat roaming is disabled

	tempflex1 = VectorZ(GetThingPos(target)) - VectorZ(GetThingPos(rbot)); // work out relative position of target to bot
	if (((tempflex1 < -1 || 1 < tempflex1) && difficulty >= 2) || (GetThingFlags(rbot) & 0x2000000)) return; // Can't fall down safely or Underwater

	// Consult the other srv cogs to see if the bot should move toward the target
	// Maintenance note: The two if-statements below are separated intentionally.
	// When combined, I found that the gmae would evaluate the expression to true
	// and execute the return statement even when srv_ext was -1.
	if (srv_ext != -1) if (!SendMessageEx(srv_ext, user7, 10213050, target, -1, -1)) return;
	if (!SendMessageEx(srv_force, user7, 10223050, target, -1, -1)) return;
	if (!SendMessageEx(srv_weapons, user7, 10233050, target, -1, -1)) return;

	AiSetMovePos(rbot, GetThingPos(target)); // by default, move directly towards target

	dist = VectorDist(GetThingPos(rbot), GetThingPos(target));
	if (dist > 0.4) // too far away, try to close in on target
	{
		if (difficulty >= 3) // on higher difficulty
		{
			if (Rand() < 0.4) // sometimes move around target
			{
				tempvector1 = VectorScale(GetThingRVec(rbot), (Rand()-0.5) * 0.4); // random left/right offset
				tempvector1 = VectorAdd(GetThingPos(target), tempvector1); // target position + random left/right offset
				AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
			}
		}
		// TODO potential code to move where target is moving
		//	movepos = VectorNorm(VectorSub(VectorAdd(GetThingPos(target), VectorScale(GetThingVel(target), 0.4)), GetThingPos(rbot)));
		//	movevec = VectorSet(VectorX(movepos), VectorY(movepos), 0.0);
		//	AiSetMovePos(rbot, movevec);
	}
	else // close range
	{
		if (difficulty >= 2)
		{
			if (Rand() < 0.6) // sometimes move around target
			{
				tempvector1 = VectorScale(GetThingRVec(rbot), (Rand()-0.5) * 0.4); // random left/right offset
				tempvector1 = VectorAdd(GetThingPos(target), tempvector1); // target position + random left/right offset
				AiSetMovePos(rbot, tempvector1); // move slightly left or right of target
			}
		}
	}

	return;

dodge:
	// dodge projectiles
	if (!allowdodge || difficulty < 3 || (difficulty < 4 && (10 * Rand() > difficulty))) return; // Difficulty 0,1,2 will never dodge. Difficulty 3 will sometimes dodge. Difficulty 4 will always dodge.

	potential = FirstThingInView(rbot, 180, 3, 0x8); // Scan for projectiles to dodge (0x8)
	while (potential != -1) // make sure projectile is not from this bot and is valid
	{
		if (rbot != GetThingParent(potential) && (GetAttachFlags(rbot) & 1))
		{
			choice = Rand();
			if (choice > 0.75)
			{
				jump = 1; // jump
			}
			else if (choice > 0.30)
			{
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '-90 0 0'), 2.0)); // slide left
			}
			else
			{
				ApplyForce(rbot, VectorScale(VectorSub(GetThingLVec(rbot), '90 0 0'), 2.0)); // slide right
			}
			allowdodge = 0;
			SetTimerEx(0.4, 400, -1, -1); // allow to dodge projectiles again in 0.4 secs
			return; // break -- don't execute multiple dodges in one pulse
		}
		potential = NextThingInView();
	}
	return;

checkspeed:
	if (reachednode) // Reached node this pulse
	{
		// See if bot is moving fast and needs to make a sharp turn
		tempvector1 = VectorNorm(GetThingVel(rbot));
		tempvector2 = VectorNorm(VectorSub(newpos, GetThingPos(rbot)));
		if (VectorLen(GetThingVel(rbot)) > 0.4 && VectorDot(tempvector1, tempvector2) < 0.7)
		{
			// If bot is not airborne, move to self position to help slow down for sharp turns
			// This check is necessary because telling an actor to move to its own position seems to
			// behave like StopThing and will reset vertical velocity like jumping and falling
			if (GetAttachFlags(rbot) || GetPhysicsFlags(rbot) & 0x100000 || GetThingFlags(rbot) & 0x2000000)
			{
				AiSetMovePos(rbot, GetThingPos(rbot));
			}
		}
	}

	if ((GetPhysicsFlags(rbot) & 0x100000) || (GetThingFlags(rbot) & 0x2000000)) // bot is in water
	{
		// Normal player WASD swim speed is about 0.6 JKU/s
		// Combining WASD with jump/crouch boosts it to about 0.9 JKU/s
		// Use the difficulty to scale the movement speed according to these values
		// This emulates a more experienced player being able to swim faster and more efficiently
		movespeed = 0.5 + 0.4 * (difficulty / 4); // Range: [0.5,0.9]

		if (BitTest(botmode, 0x100000)) // move slowly
		{
			// Override for slow swim speed
			movespeed = 0.4;
		}
	}
	else // bot is on ground or in air
	{
		// Normal player WASD run speed is about 1.33 JKU/s
		movespeed = 1.33;

		if (BitTest(botmode, 0x100000) || difficulty < 1) // move slowly or low difficulty
		{
			// Normal player WASD walk speed is about 0.66 JKU/s
			// Note that the bot will still use running animations even at this speed
			// The movespeed needs to be set around 0.5 or lower to switch to walking animations
			movespeed = 0.66;
		}

		// Surface drag reduces the bot speed from 1.33 to about 0.87
		// Scale the speed value to approximate player movement speed after reduction from drag
		// Magic number explanation: 0.87 * x = 1.33 --> x = 1.33 / 0.87 = 1.53
		// Plus a little extra because 1.53 only gets the bot up to about 1.2
		movespeed = movespeed * 1.6;

		if (!GetAttachFlags(rbot)) // bot is in the air
		{
			// Reduce bot maneuverability when in the air
			// We don't want the bot to have too much control while in the air
			// However, the effectiveness of some functions, such as obstruction jumps, depends
			// on the bot being able to accelerate forward while in the air, so we also don't
			// want to reduce this too much.
			movespeed = movespeed / 2;
		}
	}

	// allow srv-force to adjust movement speed (e.g. force speed)
	movespeed = SendMessageEx(srv_force, user7, 10223040, movespeed, -1, -1);

	AiSetMoveSpeed(rbot, movespeed);

	return;

end
