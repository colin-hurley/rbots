# Rbot Customizer Cog - Cargo Ship
#
# Server-only
# Type ID: 3000
#
# Rbots originally created by Raynar

flags=0x40

symbols

message		startup
message		user7

surface		pit0=-1								nolink
surface		pit1=-1								nolink
surface		pit2=-1								nolink
surface		pit3=-1								nolink
surface		pit4=-1								nolink
surface		pit5=-1								nolink
surface		pit6=-1								nolink
surface		pit7=-1								nolink

flex		threshold=2.0						local

int			losblocked							local
int			i									local
int			j									local
int			k									local
int			tempval1							local
int			tempval2							local
#int			tempval3							local
flex		tempflex1							local
flex		tempflex2							local
vector		tempvector1							local
vector		tempvector2							local
vector		tempvector3							local
vector		tempvector4							local
vector		vxpos0								local
vector		vxpos1								local
vector		vxpos2								local
vector		vxpos3								local

surface		pit									local
thing		rbot								local
thing		item								local
thing		potential							local
int			priority							local

end

code

startup:
	if (IsMulti() && !IsServer()) return; // Host only

	// Allow other server-side cogs to discover this one by its type
	SendTrigger(-1, 1852000, 3000, GetSelfCog(), -1, -1);

	return;

// Execute public API function for this cog
// Param 0 = Function ID
// The remaining params will be processed according to the requested function
// For example, param1 might be an index into an array.
// Returns the function-specific result of the execution
user7:
	if (GetParam(0) == 30003010) // get item priority
	{
		rbot = GetParam(1);
		item = GetParam(2);
		priority = GetParam(3);

		if (priority != -1)
		{
			potential = item;
			call checkpit;
			if (losblocked)
			{
				// Bot and item are on opposite sides of a pit, ignore item
				priority = -1;
			}
		}

		ReturnEx(priority);
		return;
	}

	if (GetParam(0) == 30003020) // pickup item
	{
		#rbot = GetParam(1);
		#item = GetParam(2);
		// No item pickup customization implemented
		ReturnEx(0); // item pickup not handled
		return;
	}

	if (GetParam(0) == 30003030) // get target priority
	{
		rbot = GetParam(1);
		potential = GetParam(2);
		priority = GetParam(3);

		if (priority != -1)
		{
			call checkpit;
			if (losblocked)
			{
				// Bot and target are on opposite sides of a pit, reduce priority
				// Bot should try to avoid the pit and attack other targets first
				priority = 0;
			}
		}

		ReturnEx(priority);
		return;
	}

	if (GetParam(0) == 30003050) // decide whether to move toward target
	{
		rbot = GetParam(1);
		potential = GetParam(2);

		call checkpit;
		if (losblocked)
		{
			// Bot and target are on opposite sides of a pit, do not move toward target
			ReturnEx(0);
			return;
		}

		// There is no pit between the bot and the target, so allow moving toward target
		ReturnEx(1);
		return;
	}

	// Report error if function ID does not match anything above
	jkStringClear();
	jkStringConcatFormattedInt(GetSenderRef(), "rbot-custom-cargo.cog :: ERROR :: Cog %d");
	jkStringConcatFormattedInt(GetParam(0), " has requested an invalid function ID, %d");
	jkStringOutput(-1, -1);
	return;

# Check to see if LOS from the bot to another thing passes over (or through) a pit
# Input values:
#   rbot = from thing
#   potential = to thing
# Output values:
#   losblocked = 1 if LOS passes over a pit, 0 otherwise
checkpit:
	losblocked = 0;

	for (i = 0 ; i < 8 ; i = i + 1)
	{
		pit = pit0[i];
		if (pit != -1)
		{
			for (j = 0 ; j < GetNumSurfaceVertices(pit) ; j = j + 1)
			{
				tempval1 = j - 1;
				if (tempval1 < 0) tempval1 = GetNumSurfaceVertices(pit) - 1; // special case: pair of first and last vertices
				vxpos0 = GetSurfaceVertexPos(pit, tempval1);
				vxpos1 = GetSurfaceVertexPos(pit, j);
				tempvector1 = VectorNorm(VectorCross(VectorSub(vxpos0, vxpos1), '0 0 1')); // normal vector of pit edge vertical plane
				tempvector2 = VectorSub(vxpos0, GetThingPos(rbot));
				tempflex1 = VectorDot(tempvector1, tempvector2);
				if (tempflex1 > 0) // edge plane is between the bot and the pit
				{
					// Compute the upper edge virtual vertices of the edge plane
					vxpos2 = VectorAdd(vxpos1, VectorSet(0, 0, threshold));
					vxpos3 = VectorAdd(vxpos0, VectorSet(0, 0, threshold));

					tempvector2 = VectorSub(GetThingPos(potential), vxpos0);
					tempflex2 = VectorDot(tempvector1, tempvector2);
					if (tempflex2 > 0) // the potential is on the other side of the edge plane
					{
						// The things are on opposite sides of the edge plane
						// See if the bot would need to cross over this pit edge to reach the potential
						tempflex1 = tempflex1 / (tempflex1 + tempflex2);
						tempvector2 = VectorAdd(GetThingPos(rbot), VectorScale(VectorSub(GetThingPos(potential), GetThingPos(rbot)), tempflex1)); // point of intersection with adjoin plane
						losblocked = 1; // assume collision with this virtual edge plane surface until we find otherwise
						for (k = 0 ; k < 4 ; k = k + 1)
						{
							tempval2 = k - 1;
							if (tempval2 < 0) tempval2 = 3; // special case: pair of first and last vertices
							tempvector3 = VectorCross(VectorSub(vxpos0[k], vxpos0[tempval2]), tempvector1); // edge normal (toward virtual surface)
							tempvector4 = VectorSub(tempvector2, vxpos0[k]); // virtual surface vertex toraard edge plane intersection point
							tempflex2 = VectorDot(tempvector3, tempvector4); // check if intersection point is within this edge
							if (tempflex2 < 0)
							{
								// Outside this edge of the adjoin surface, no collision with this surface
								// The point of intersection needs to be inside all edges of the surface for a collision to occur
								losblocked = 0;
								k = 4; // break
							}
						}
						if (losblocked)
						{
							// This pit edge is directly in the path between the bot and the pos
							return;
						}
					}
				}
			}
		}
	}

	return;

end
